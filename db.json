{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Axe/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/bitbug_favicon.ico","path":"img/bitbug_favicon.ico","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/fuzi.jpg","path":"img/fuzi.jpg","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/qq.png","path":"img/qq.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/search.png","path":"img/search.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/Counter.js","path":"js/Counter.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/particles.js","path":"js/particles.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1,"renderable":1},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/react-native环境配置.md","hash":"b21eb71541bd8e71603388fc444e6cdd40bfc93d","modified":1647519676709},{"_id":"source/_posts/Effect-Hook.md","hash":"8a563cc11fd45a0e616e647f31436820d6839859","modified":1647519676708},{"_id":"source/_posts/react-native组件的生命周期.md","hash":"9f26d0628e74aa887c3c3263fe4edcf96d01e6f3","modified":1647519676712},{"_id":"source/aboutMe/index.md","hash":"f24f484f92b351323412f7eb8da1389a5972ae36","modified":1647519676715},{"_id":"source/categories/index.md","hash":"c8dcfdb7f5e59a8eeacc63380726abbbab2d1514","modified":1647519676717},{"_id":"source/tags/index.md","hash":"489c8fb2bcfdd226cceec2d5160e6ea51fd5597c","modified":1647519676719},{"_id":"source/_posts/react-native简介.md","hash":"09717c4c7b2bc0b069cffbf9e68e6086ba28fa0d","modified":1647519676710},{"_id":"source/_posts/setState.md","hash":"c531ce7dbb836b002920f802ea2d2b62c815edea","modified":1647519676713},{"_id":"themes/Axe/_config.yml","hash":"560abfc6c5697f1a4082f5327c0f8b335b997fd8","modified":1647519676722},{"_id":"themes/Axe/package.json","hash":"c265b508542d0fbebf146305097e1f53d264fc25","modified":1647519676767},{"_id":"themes/Axe/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1647519676757},{"_id":"themes/Axe/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1647519676758},{"_id":"themes/Axe/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1647519676759},{"_id":"themes/Axe/layout/layout.ejs","hash":"acbcab84260ffe7168b898ccc86dab99da2e44cb","modified":1647519676760},{"_id":"themes/Axe/layout/page.ejs","hash":"f910bf24f1da60c97fc59fdcb96b7eabda5f1d9c","modified":1647519676762},{"_id":"themes/Axe/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1647519676763},{"_id":"themes/Axe/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1647519676765},{"_id":"themes/Axe/layout/_partial/after-footer.ejs","hash":"15bcb523e600f55e8f6cc288cac1e043c8c2ba02","modified":1647519676724},{"_id":"themes/Axe/layout/_partial/archive-post.ejs","hash":"5ad682a62264a8b35dc621f00aa123984d6f1cf2","modified":1647519676726},{"_id":"themes/Axe/layout/_partial/archive.ejs","hash":"fd122e7047fb05fa88948e8bad9febd79b7143fa","modified":1647519676727},{"_id":"themes/Axe/layout/_partial/article.ejs","hash":"1c8e965ef48e6f13bde6494a3d63dba9798bbac1","modified":1647519676729},{"_id":"themes/Axe/layout/_partial/baidu_tongji.ejs","hash":"df67dae10b3d5390ca5ff329bf36ff60082bf664","modified":1647519676730},{"_id":"themes/Axe/layout/_partial/footer.ejs","hash":"007dd3287a11f3b0ec1d2debbf65cb4e5f9e2ce7","modified":1647519676731},{"_id":"themes/Axe/layout/_partial/google_analytics.ejs","hash":"0bd77fcbe30c5bc323222c1cfee592300abfd42f","modified":1647519676733},{"_id":"themes/Axe/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1647519676736},{"_id":"themes/Axe/layout/_partial/head.ejs","hash":"bcfa5b67ca4f02f40e9ca898a3d2e85f5fa1a523","modified":1647519676735},{"_id":"themes/Axe/layout/_partial/mathjax.ejs","hash":"09f982c283160324de40cc6ae4267b2075edeed1","modified":1647519676739},{"_id":"themes/Axe/layout/_partial/left-col.ejs","hash":"4b60cc19c1ac2e261a0906184b1b435697a9c2c6","modified":1647519676737},{"_id":"themes/Axe/layout/_partial/mobile-nav.ejs","hash":"998e065e0ea49852281684fa6e2629780053abec","modified":1647519676740},{"_id":"themes/Axe/layout/_partial/search.ejs","hash":"6250423092d8c69d63e14d390fb3df30c6f77f1c","modified":1647519676753},{"_id":"themes/Axe/layout/_widget/Counter.ejs","hash":"472ca8ac00a7143904689b6ce9ea6defd03f0cfc","modified":1647519676755},{"_id":"themes/Axe/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1647519676769},{"_id":"themes/Axe/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1647519676793},{"_id":"themes/Axe/source/css/style.styl","hash":"7fe190e5e0105fd787d413fbab98a3e15408e026","modified":1647519676804},{"_id":"themes/Axe/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1647519676806},{"_id":"themes/Axe/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1647519676807},{"_id":"themes/Axe/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1647519676809},{"_id":"themes/Axe/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1647519676811},{"_id":"themes/Axe/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1647519676810},{"_id":"themes/Axe/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1647519676813},{"_id":"themes/Axe/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1647519676823},{"_id":"themes/Axe/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1647519676825},{"_id":"themes/Axe/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1647519676826},{"_id":"themes/Axe/source/img/bitbug_favicon.ico","hash":"072671fbd93cdfb13ff7c55fcc3de85f0317aea2","modified":1647519676829},{"_id":"themes/Axe/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1647519676830},{"_id":"themes/Axe/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1647519676831},{"_id":"themes/Axe/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1647519676832},{"_id":"themes/Axe/source/img/favicon.ico","hash":"072671fbd93cdfb13ff7c55fcc3de85f0317aea2","modified":1647519676835},{"_id":"themes/Axe/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1647519676834},{"_id":"themes/Axe/source/img/fuzi.jpg","hash":"98c6d82e703026617ef3a67c907600398a5798de","modified":1647519676837},{"_id":"themes/Axe/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1647519676840},{"_id":"themes/Axe/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1647519676841},{"_id":"themes/Axe/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1647519676838},{"_id":"themes/Axe/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1647519676842},{"_id":"themes/Axe/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1647519676843},{"_id":"themes/Axe/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1647519676845},{"_id":"themes/Axe/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1647519676846},{"_id":"themes/Axe/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1647519676847},{"_id":"themes/Axe/source/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1647519676849},{"_id":"themes/Axe/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1647519676850},{"_id":"themes/Axe/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1647519676851},{"_id":"themes/Axe/source/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1647519676852},{"_id":"themes/Axe/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1647519676854},{"_id":"themes/Axe/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1647519676855},{"_id":"themes/Axe/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1647519676857},{"_id":"themes/Axe/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1647519676858},{"_id":"themes/Axe/source/js/Counter.js","hash":"ef766189974c8a6bdd5de586e8bd7daf304f617d","modified":1647519676860},{"_id":"themes/Axe/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1647519676861},{"_id":"themes/Axe/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1647519676862},{"_id":"themes/Axe/source/js/main.js","hash":"928b4881340e10c1255aef8905b1b3e77aea3d97","modified":1647519676863},{"_id":"themes/Axe/source/js/mobile.js","hash":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1647519676865},{"_id":"themes/Axe/source/js/particles.js","hash":"b17f624ce45ef416cac4b0ca595d9a56149df2dc","modified":1647519676866},{"_id":"themes/Axe/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1647519676868},{"_id":"themes/Axe/layout/_partial/post/category.ejs","hash":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1647519676742},{"_id":"themes/Axe/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1647519676745},{"_id":"themes/Axe/layout/_partial/post/date.ejs","hash":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1647519676743},{"_id":"themes/Axe/layout/_partial/post/nav.ejs","hash":"e1fd94b1e4655b20018be6c90fa1f9c523274a50","modified":1647519676746},{"_id":"themes/Axe/layout/_partial/post/share.ejs","hash":"b91ada27deced117d1a6524f7fd406f80281d38f","modified":1647519676747},{"_id":"themes/Axe/layout/_partial/post/tag.ejs","hash":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1647519676749},{"_id":"themes/Axe/layout/_partial/post/title.ejs","hash":"8fc5f697aed67921327caa275e2787122845f2b7","modified":1647519676751},{"_id":"themes/Axe/layout/_partial/post/viewCounter.ejs","hash":"f23d808e13dfcd1d637c07cc02dc8cf9d371192c","modified":1647519676752},{"_id":"themes/Axe/source/css/_partial/archive.styl","hash":"f8ffdd559619e67213444cace775e2f54e2c40f2","modified":1647519676771},{"_id":"themes/Axe/source/css/_partial/article.styl","hash":"dd58abb551a7a5c1b8650add80b4ad82eb987786","modified":1647519676772},{"_id":"themes/Axe/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1647519676773},{"_id":"source/_posts/state-hook.md","hash":"c01e840c2aaab05c903b17754e757260a9a5b66c","modified":1647519676715},{"_id":"themes/Axe/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1647519676777},{"_id":"themes/Axe/source/css/_partial/highlight.styl","hash":"8987b455f11a141d8507d722ad48241add1b0bf0","modified":1647519676776},{"_id":"themes/Axe/source/css/_partial/main.styl","hash":"bc1fb457d4efea4915347547c0457ed7e861f48a","modified":1647519676779},{"_id":"themes/Axe/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1647519676781},{"_id":"themes/Axe/source/css/_partial/mobile.styl","hash":"931f3abd229e84b04d66169299fbb086cfc63acf","modified":1647519676782},{"_id":"themes/Axe/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1647519676783},{"_id":"themes/Axe/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1647519676784},{"_id":"themes/Axe/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1647519676786},{"_id":"themes/Axe/source/css/_partial/tagcloud.styl","hash":"255e1ce6480050b5901ee69a2ac1178241f06d2c","modified":1647519676787},{"_id":"themes/Axe/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1647519676788},{"_id":"themes/Axe/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1647519676790},{"_id":"themes/Axe/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1647519676792},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1647519676796},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1647519676799},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1647519676801},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1647519676802},{"_id":"themes/Axe/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1647519676815},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1647519676816},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1647519676818},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1647519676819},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1647519676820},{"_id":"themes/Axe/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1647519676822},{"_id":"themes/Axe/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1647519676775},{"_id":"themes/Axe/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1647519676797},{"_id":"public/aboutMe/index.html","hash":"3972011bdc9f563e7a00a7690a5eee9a405ad3b1","modified":1647583850646},{"_id":"public/categories/index.html","hash":"3a5ce24b7e0b4e3d5b5cd8d8e6b6e4a202f8fbd1","modified":1647583850646},{"_id":"public/tags/index.html","hash":"955717805f6e07d213a84d80aa3619f2c0a114f2","modified":1647583850646},{"_id":"public/2018/11/27/setState/index.html","hash":"99312dbd252804ae6f4783ae9aa9d8ac37beb807","modified":1647583850646},{"_id":"public/2018/11/07/react-native环境配置/index.html","hash":"7a810940be96ef9bba25518df098efeea35d890b","modified":1647583850646},{"_id":"public/2018/11/05/react-native简介/index.html","hash":"7df5b9ff32e67f2586ec5c32bb1fbd6c24c89d80","modified":1647583850646},{"_id":"public/archives/index.html","hash":"d20348b3b1e1f86c48e8f81af3dbb2b7949ee9d4","modified":1647583850646},{"_id":"public/archives/2018/index.html","hash":"a598a7e2887630596ac0cf6a924ea4dc50de442c","modified":1647583850646},{"_id":"public/archives/2018/11/index.html","hash":"87057b5cb0055cd56988745645423ec288bff611","modified":1647583850646},{"_id":"public/categories/react-native/index.html","hash":"308c2e1ea81c70cfecd056e22befc99dbc1a377e","modified":1647583850646},{"_id":"public/categories/react/index.html","hash":"f288aa19ff8979a9c03e96093f75908f670a466f","modified":1647583850646},{"_id":"public/categories/react/react-hooks/index.html","hash":"97a3d7c5552ce74201385eabe737df21796d15d7","modified":1647583850646},{"_id":"public/tags/react-native/index.html","hash":"45d1d8ecf0565aa0149bbd70ead538334401dbd0","modified":1647583850646},{"_id":"public/tags/react/index.html","hash":"3a958b738ee4669209b5f2d4423df7fa8a142b07","modified":1647583850646},{"_id":"public/tags/react-hooks/index.html","hash":"53e87e990918e300efad868cd83552bd07bdb10f","modified":1647583850646},{"_id":"public/2018/11/27/state-hook/index.html","hash":"d73342318b2a73e666d14e5e7b1d2355ec093d37","modified":1647583850646},{"_id":"public/2018/11/27/Effect-Hook/index.html","hash":"da8e95d46f5cc75a9f19222208eb6eacb0c71742","modified":1647583850646},{"_id":"public/2018/11/08/react-native组件的生命周期/index.html","hash":"04450f5b997a8adc889c795202c96dbb4410021c","modified":1647583850646},{"_id":"public/index.html","hash":"f011d4c5a4e6411b33051045c8b2f6b2576c84d9","modified":1647583850646},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1647583850646},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1647583850646},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1647583850646},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1647583850646},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1647583850646},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1647583850646},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1647583850646},{"_id":"public/img/bitbug_favicon.ico","hash":"072671fbd93cdfb13ff7c55fcc3de85f0317aea2","modified":1647583850646},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1647583850646},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1647583850646},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1647583850646},{"_id":"public/img/favicon.ico","hash":"072671fbd93cdfb13ff7c55fcc3de85f0317aea2","modified":1647583850646},{"_id":"public/img/fuzi.jpg","hash":"98c6d82e703026617ef3a67c907600398a5798de","modified":1647583850646},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1647583850646},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1647583850646},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1647583850646},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1647583850646},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1647583850646},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1647583850646},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1647583850646},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1647583850646},{"_id":"public/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1647583850646},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1647583850646},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1647583850646},{"_id":"public/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1647583850646},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1647583850646},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1647583850646},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1647583850646},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1647583850646},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1647583850646},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1647583850646},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1647583850646},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1647583850646},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1647583850646},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1647583850646},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1647583850646},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1647583850646},{"_id":"public/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1647583850646},{"_id":"public/js/main.js","hash":"5e92a3694111e5ae5aca37c79157218d35f2e63b","modified":1647583850646},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1647583850646},{"_id":"public/css/style.css","hash":"a6c3a554338f25ea5ec05d3e7786698c51167de2","modified":1647583850646},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1647583850646},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1647583850646},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1647583850646},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1647583850646},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1647583850646},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1647583850646},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1647583850646},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1647583850646},{"_id":"public/js/particles.js","hash":"c2e991597d14ab770467aacd299e88ea108c2576","modified":1647583850646},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1647583850646}],"Category":[{"name":"react-native","_id":"cl0w0vvqc00047cdqhrcab467"},{"name":"react","_id":"cl0w0vvqr000f7cdq68xtciz7"},{"name":"react-hooks","parent":"cl0w0vvqr000f7cdq68xtciz7","_id":"cl0w0vvqu000q7cdq3szlbt30"}],"Data":[],"Page":[{"title":"个人经历","date":"2018-11-05T06:16:20.000Z","_content":"# 关于作者\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"aboutMe/index.md","raw":"---\ntitle: 个人经历\ndate: 2018-11-05 14:16:20\n\n---\n# 关于作者\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","updated":"2022-03-17T12:21:16.715Z","path":"aboutMe/index.html","comments":1,"layout":"page","_id":"cl0w0vvq400007cdqa8yjfb57","content":"<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"categories","date":"2018-11-05T08:35:31.000Z","_content":"category_map:\n        hexo:hexo\n        react-native:react-native\n        ubuntu:ubuntu\n        computer vision: computer-vision","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-05 16:35:31\n---\ncategory_map:\n        hexo:hexo\n        react-native:react-native\n        ubuntu:ubuntu\n        computer vision: computer-vision","updated":"2022-03-17T12:21:16.717Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl0w0vvqa00027cdq81l48y08","content":"<p>category_map:<br>        hexo:hexo<br>        react-native:react-native<br>        ubuntu:ubuntu<br>        computer vision: computer-vision</p>\n","site":{"data":{}},"excerpt":"","more":"<p>category_map:<br>        hexo:hexo<br>        react-native:react-native<br>        ubuntu:ubuntu<br>        computer vision: computer-vision</p>\n"},{"title":"tags","date":"2018-11-05T08:31:51.000Z","_content":"tag_map:\n\treact-native:react-native\n\tlinux:linux\n\tubuntu:ubuntu\n\tvim:vim\n\ttmux:tmux\n\thexo:hexo\n\tyolo:yolo\n\topencv:opencv\n\tcomputer vision:computer-vision\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-05 16:31:51\n---\ntag_map:\n\treact-native:react-native\n\tlinux:linux\n\tubuntu:ubuntu\n\tvim:vim\n\ttmux:tmux\n\thexo:hexo\n\tyolo:yolo\n\topencv:opencv\n\tcomputer vision:computer-vision\n","updated":"2022-03-17T12:21:16.719Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl0w0vvqg00067cdqaebo8tpp","content":"<p>tag_map:<br>    react-native:react-native<br>    linux:linux<br>    ubuntu:ubuntu<br>    vim:vim<br>    tmux:tmux<br>    hexo:hexo<br>    yolo:yolo<br>    opencv:opencv<br>    computer vision:computer-vision</p>\n","site":{"data":{}},"excerpt":"","more":"<p>tag_map:<br>    react-native:react-native<br>    linux:linux<br>    ubuntu:ubuntu<br>    vim:vim<br>    tmux:tmux<br>    hexo:hexo<br>    yolo:yolo<br>    opencv:opencv<br>    computer vision:computer-vision</p>\n"}],"Post":[{"title":"react-native环境配置","date":"2018-11-07T14:41:17.000Z","type":"tags","_content":"\n### react-native window开发环境搭建\n\n一、安装JDK\n\n1. 从 [Java官网](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) 下载JDK并安装。\n\n2. 安装成功可以用java -version查看版本信息，或用 java -c 检测是否安装成功\n <!-- more -->\n\n3. 配置Java的环境变量\n\n   * 添加环境变量JAVA_HOME = C:\\Program Files\\Java\\jdk1.8.0_45;\n\n   *  Path+=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n   * CLASSPATH+=%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n\nJAVA_HOME变量：\n\n![JAVA_HOME](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102408874-1736443714.png)\n\n​\t\n\nCLASSPATH变量\n\n![CLASSPATH变量](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102528280-1866646025.png)\n\n二、安装 android SDK\n\n1. 下载 android sdk 并安装；\n\n2. 安装完成后根据 react-native官网 安装 SDK Tools;\n\n3. 配置android环境变量\n\n * 添加 ANDROID_HOME 变量\n ![android-home](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709103101952-2112122131.png)\n\n* 在 Path 变量里添加 %ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools;\n\n三、安装node.js git 环境\n\n四、安装react-native 的命令行工具 react-native-cli\n\n```\nnpm install react-native-cli -g\n```\n\n***备注：*** 官网讲需要安装 python 环境，但是个人感觉好像没用，一直也没安装过，所以安不安装看个人；\n\n\n### 创建我们的项目\n\n1. 生成项目\n```\nreact-native init myApp\n```\n\n\n2. 安装项目依赖包\n```\nnpm install\n```\n\n3. 连接真机或者模拟机，在终端运行 adb devices 查看是否连接设备，真机需要打开开发者模式，然后运行 react-native run-android 生成 apk 安装包。\n\n\n4. 运行 package.json ，命令行运行\n\n```\nreact-native start 或者  npm start\n```\n\n\n5. 打开手机上我们安装的app，会出现如下所示的情况 :\n\n![error](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709113415499-1546806111.png)\n\n\n这时候摇一摇手机，点击Dev Settings后，点击Debug server host & port for device,设置IP和端口\n\n![reload](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114104467-1570314774.jpg)\n\n再次摇一摇手机，选择Reload ，程序就运行起来，出现Welcome to React Native！\n\n![sucess](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114253046-223755573.png)\n\n现在就可以尽情的写我们的 code 了。。。\n\n","source":"_posts/react-native环境配置.md","raw":"---\ntitle: react-native环境配置\ndate: 2018-11-07 22:41:17\ntype: 'tags'\ntags:                 \n- react-native\ncategories:\n- react-native\n---\n\n### react-native window开发环境搭建\n\n一、安装JDK\n\n1. 从 [Java官网](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) 下载JDK并安装。\n\n2. 安装成功可以用java -version查看版本信息，或用 java -c 检测是否安装成功\n <!-- more -->\n\n3. 配置Java的环境变量\n\n   * 添加环境变量JAVA_HOME = C:\\Program Files\\Java\\jdk1.8.0_45;\n\n   *  Path+=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n   * CLASSPATH+=%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n\nJAVA_HOME变量：\n\n![JAVA_HOME](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102408874-1736443714.png)\n\n​\t\n\nCLASSPATH变量\n\n![CLASSPATH变量](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102528280-1866646025.png)\n\n二、安装 android SDK\n\n1. 下载 android sdk 并安装；\n\n2. 安装完成后根据 react-native官网 安装 SDK Tools;\n\n3. 配置android环境变量\n\n * 添加 ANDROID_HOME 变量\n ![android-home](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709103101952-2112122131.png)\n\n* 在 Path 变量里添加 %ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools;\n\n三、安装node.js git 环境\n\n四、安装react-native 的命令行工具 react-native-cli\n\n```\nnpm install react-native-cli -g\n```\n\n***备注：*** 官网讲需要安装 python 环境，但是个人感觉好像没用，一直也没安装过，所以安不安装看个人；\n\n\n### 创建我们的项目\n\n1. 生成项目\n```\nreact-native init myApp\n```\n\n\n2. 安装项目依赖包\n```\nnpm install\n```\n\n3. 连接真机或者模拟机，在终端运行 adb devices 查看是否连接设备，真机需要打开开发者模式，然后运行 react-native run-android 生成 apk 安装包。\n\n\n4. 运行 package.json ，命令行运行\n\n```\nreact-native start 或者  npm start\n```\n\n\n5. 打开手机上我们安装的app，会出现如下所示的情况 :\n\n![error](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709113415499-1546806111.png)\n\n\n这时候摇一摇手机，点击Dev Settings后，点击Debug server host & port for device,设置IP和端口\n\n![reload](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114104467-1570314774.jpg)\n\n再次摇一摇手机，选择Reload ，程序就运行起来，出现Welcome to React Native！\n\n![sucess](http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114253046-223755573.png)\n\n现在就可以尽情的写我们的 code 了。。。\n\n","slug":"react-native环境配置","published":1,"updated":"2022-03-17T12:21:16.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w0vvq700017cdqc43lc228","content":"<h3 id=\"react-native-window开发环境搭建\"><a href=\"#react-native-window开发环境搭建\" class=\"headerlink\" title=\"react-native window开发环境搭建\"></a>react-native window开发环境搭建</h3><p>一、安装JDK</p>\n<ol>\n<li><p>从 <a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">Java官网</a> 下载JDK并安装。</p>\n</li>\n<li><p>安装成功可以用java -version查看版本信息，或用 java -c 检测是否安装成功</p>\n<span id=\"more\"></span></li>\n<li><p>配置Java的环境变量</p>\n<ul>\n<li><p>添加环境变量JAVA_HOME = C:\\Program Files\\Java\\jdk1.8.0_45;</p>\n</li>\n<li><p> Path+=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</p>\n</li>\n<li><p>CLASSPATH+=%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>JAVA_HOME变量：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102408874-1736443714.png\" alt=\"JAVA_HOME\"></p>\n<p>​    </p>\n<p>CLASSPATH变量</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102528280-1866646025.png\" alt=\"CLASSPATH变量\"></p>\n<p>二、安装 android SDK</p>\n<ol>\n<li><p>下载 android sdk 并安装；</p>\n</li>\n<li><p>安装完成后根据 react-native官网 安装 SDK Tools;</p>\n</li>\n<li><p>配置android环境变量</p>\n</li>\n</ol>\n<ul>\n<li><p>添加 ANDROID_HOME 变量<br><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709103101952-2112122131.png\" alt=\"android-home\"></p>\n</li>\n<li><p>在 Path 变量里添加 %ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools;</p>\n</li>\n</ul>\n<p>三、安装node.js git 环境</p>\n<p>四、安装react-native 的命令行工具 react-native-cli</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-native-cli -g</span><br></pre></td></tr></table></figure>\n\n<p><em><strong>备注：</strong></em> 官网讲需要安装 python 环境，但是个人感觉好像没用，一直也没安装过，所以安不安装看个人；</p>\n<h3 id=\"创建我们的项目\"><a href=\"#创建我们的项目\" class=\"headerlink\" title=\"创建我们的项目\"></a>创建我们的项目</h3><ol>\n<li>生成项目<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native init myApp</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"2\">\n<li><p>安装项目依赖包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></li>\n<li><p>连接真机或者模拟机，在终端运行 adb devices 查看是否连接设备，真机需要打开开发者模式，然后运行 react-native run-android 生成 apk 安装包。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>运行 package.json ，命令行运行</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native start 或者  npm start</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"5\">\n<li>打开手机上我们安装的app，会出现如下所示的情况 :</li>\n</ol>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709113415499-1546806111.png\" alt=\"error\"></p>\n<p>这时候摇一摇手机，点击Dev Settings后，点击Debug server host &amp; port for device,设置IP和端口</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114104467-1570314774.jpg\" alt=\"reload\"></p>\n<p>再次摇一摇手机，选择Reload ，程序就运行起来，出现Welcome to React Native！</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114253046-223755573.png\" alt=\"sucess\"></p>\n<p>现在就可以尽情的写我们的 code 了。。。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"react-native-window开发环境搭建\"><a href=\"#react-native-window开发环境搭建\" class=\"headerlink\" title=\"react-native window开发环境搭建\"></a>react-native window开发环境搭建</h3><p>一、安装JDK</p>\n<ol>\n<li><p>从 <a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">Java官网</a> 下载JDK并安装。</p>\n</li>\n<li><p>安装成功可以用java -version查看版本信息，或用 java -c 检测是否安装成功</p>","more":"</li>\n<li><p>配置Java的环境变量</p>\n<ul>\n<li><p>添加环境变量JAVA_HOME = C:\\Program Files\\Java\\jdk1.8.0_45;</p>\n</li>\n<li><p> Path+=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</p>\n</li>\n<li><p>CLASSPATH+=%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>JAVA_HOME变量：</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102408874-1736443714.png\" alt=\"JAVA_HOME\"></p>\n<p>​    </p>\n<p>CLASSPATH变量</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709102528280-1866646025.png\" alt=\"CLASSPATH变量\"></p>\n<p>二、安装 android SDK</p>\n<ol>\n<li><p>下载 android sdk 并安装；</p>\n</li>\n<li><p>安装完成后根据 react-native官网 安装 SDK Tools;</p>\n</li>\n<li><p>配置android环境变量</p>\n</li>\n</ol>\n<ul>\n<li><p>添加 ANDROID_HOME 变量<br><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709103101952-2112122131.png\" alt=\"android-home\"></p>\n</li>\n<li><p>在 Path 变量里添加 %ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools;</p>\n</li>\n</ul>\n<p>三、安装node.js git 环境</p>\n<p>四、安装react-native 的命令行工具 react-native-cli</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-native-cli -g</span><br></pre></td></tr></table></figure>\n\n<p><em><strong>备注：</strong></em> 官网讲需要安装 python 环境，但是个人感觉好像没用，一直也没安装过，所以安不安装看个人；</p>\n<h3 id=\"创建我们的项目\"><a href=\"#创建我们的项目\" class=\"headerlink\" title=\"创建我们的项目\"></a>创建我们的项目</h3><ol>\n<li>生成项目<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native init myApp</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"2\">\n<li><p>安装项目依赖包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></li>\n<li><p>连接真机或者模拟机，在终端运行 adb devices 查看是否连接设备，真机需要打开开发者模式，然后运行 react-native run-android 生成 apk 安装包。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>运行 package.json ，命令行运行</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native start 或者  npm start</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"5\">\n<li>打开手机上我们安装的app，会出现如下所示的情况 :</li>\n</ol>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709113415499-1546806111.png\" alt=\"error\"></p>\n<p>这时候摇一摇手机，点击Dev Settings后，点击Debug server host &amp; port for device,设置IP和端口</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114104467-1570314774.jpg\" alt=\"reload\"></p>\n<p>再次摇一摇手机，选择Reload ，程序就运行起来，出现Welcome to React Native！</p>\n<p><img src=\"http://images2015.cnblogs.com/blog/546421/201607/546421-20160709114253046-223755573.png\" alt=\"sucess\"></p>\n<p>现在就可以尽情的写我们的 code 了。。。</p>"},{"title":"react-native组件的生命周期","date":"2018-11-08T09:47:23.000Z","type":"tags","_content":"\n## 概述\n所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN 组件的生命周期整理如下图：\n\n<!--more-->\n\n![生命周期](https://img.race604.com/3-3-component-lifecycle.jpg)\n\n如图，可以把组件生命周期大致分为三个阶段：\n\n* 第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；\n* 第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；\n* 第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。\n\n## 生命周期回调函数\n\n下面来详细介绍生命周期中的各回调函数。\n\n##### *getDefaultProps*\n在组件创建之前，会先调用 getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 getInitialState()，来初始化组件的状态。\n\n##### *componentWillMount*\n然后，准备加载组件，会调用 componentWillMount(), 这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。\n\n##### *componentDidMount*\n在组件第一次绘制之后，会调用 componentDidMount()，通知组件已经加载完成。这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 componentDidMount()，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发.\n\n##### *componentWillReceiveProps*\n如果组件收到新的属性（props），就会调用 componentWillReceiveProps(),输入参数 nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 this.setState() 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 render() 调用。如下：\n```\ncomponentWillReceiveProps(nextProps) {  \n  this.setState({\n    oldProps: nextProps\n  });\n}\n```\n\n##### *shouldComponentUpdate*\n当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate(…)，输入参数 nextProps 和上面的 componentWillReceiveProps 函数一样，nextState 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 true 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。\n\n默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。\n\n##### *componentWillUpdate*\n如果组件状态或者属性改变，并且上面的 shouldComponentUpdate(…) 返回为 true，就会开始准更新组件，并调用 componentWillUpdate()，输入参数与 shouldComponentUpdate 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了。\n\n##### *componentDidUpdate*\n调用了 render() 更新完成界面之后，会调用 componentDidUpdate() 来得到通知，因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 prevProps 和 prevState。\n\n##### *componentWillUnmount*\n当组件要被从界面上移除的时候，就会调用 componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等.\n\n## 总结\n到这里，RN 的组件的完整的生命都介绍完了，在回头来看一下前面的图，就比较清晰了，把生命周期的回调函数总结成如下表格：\n\n|生命周期|\t调用次数\t|能否使用 setSate()|\n|-------|-----|-----|\n|getDefaultProps|\t1(全局调用一次)\t|否|\n|getInitialState\t|1\t|否|\n|componentWillMount|\t1\t|是|\n|render\t|>=1|\t否|\n|componentDidMount\t|1\t|是|\n|componentWillReceiveProps|\t>=0\t|是|\n|shouldComponentUpdate|\t>=0\t|否|\n|componentWillUpdate\t|>=0\t|否|\n|componentDidUpdate\t|>=0|\t否|\n|componentWillUnmount|\t1| 否|","source":"_posts/react-native组件的生命周期.md","raw":"---\ntitle: react-native组件的生命周期\ndate: 2018-11-08 17:47:23\ntype: 'tags'\ntags:                 \n- react-native\n- react\ncategories:\n- react-native\n---\n\n## 概述\n所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN 组件的生命周期整理如下图：\n\n<!--more-->\n\n![生命周期](https://img.race604.com/3-3-component-lifecycle.jpg)\n\n如图，可以把组件生命周期大致分为三个阶段：\n\n* 第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；\n* 第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；\n* 第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。\n\n## 生命周期回调函数\n\n下面来详细介绍生命周期中的各回调函数。\n\n##### *getDefaultProps*\n在组件创建之前，会先调用 getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 getInitialState()，来初始化组件的状态。\n\n##### *componentWillMount*\n然后，准备加载组件，会调用 componentWillMount(), 这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。\n\n##### *componentDidMount*\n在组件第一次绘制之后，会调用 componentDidMount()，通知组件已经加载完成。这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 componentDidMount()，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发.\n\n##### *componentWillReceiveProps*\n如果组件收到新的属性（props），就会调用 componentWillReceiveProps(),输入参数 nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 this.setState() 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 render() 调用。如下：\n```\ncomponentWillReceiveProps(nextProps) {  \n  this.setState({\n    oldProps: nextProps\n  });\n}\n```\n\n##### *shouldComponentUpdate*\n当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate(…)，输入参数 nextProps 和上面的 componentWillReceiveProps 函数一样，nextState 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 true 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。\n\n默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。\n\n##### *componentWillUpdate*\n如果组件状态或者属性改变，并且上面的 shouldComponentUpdate(…) 返回为 true，就会开始准更新组件，并调用 componentWillUpdate()，输入参数与 shouldComponentUpdate 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了。\n\n##### *componentDidUpdate*\n调用了 render() 更新完成界面之后，会调用 componentDidUpdate() 来得到通知，因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 prevProps 和 prevState。\n\n##### *componentWillUnmount*\n当组件要被从界面上移除的时候，就会调用 componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等.\n\n## 总结\n到这里，RN 的组件的完整的生命都介绍完了，在回头来看一下前面的图，就比较清晰了，把生命周期的回调函数总结成如下表格：\n\n|生命周期|\t调用次数\t|能否使用 setSate()|\n|-------|-----|-----|\n|getDefaultProps|\t1(全局调用一次)\t|否|\n|getInitialState\t|1\t|否|\n|componentWillMount|\t1\t|是|\n|render\t|>=1|\t否|\n|componentDidMount\t|1\t|是|\n|componentWillReceiveProps|\t>=0\t|是|\n|shouldComponentUpdate|\t>=0\t|否|\n|componentWillUpdate\t|>=0\t|否|\n|componentDidUpdate\t|>=0|\t否|\n|componentWillUnmount|\t1| 否|","slug":"react-native组件的生命周期","published":1,"updated":"2022-03-17T12:21:16.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w0vvqa00037cdqeg4fhn3r","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN 组件的生命周期整理如下图：</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://img.race604.com/3-3-component-lifecycle.jpg\" alt=\"生命周期\"></p>\n<p>如图，可以把组件生命周期大致分为三个阶段：</p>\n<ul>\n<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>\n<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>\n<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>\n</ul>\n<h2 id=\"生命周期回调函数\"><a href=\"#生命周期回调函数\" class=\"headerlink\" title=\"生命周期回调函数\"></a>生命周期回调函数</h2><p>下面来详细介绍生命周期中的各回调函数。</p>\n<h5 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a><em>getDefaultProps</em></h5><p>在组件创建之前，会先调用 getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 getInitialState()，来初始化组件的状态。</p>\n<h5 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a><em>componentWillMount</em></h5><p>然后，准备加载组件，会调用 componentWillMount(), 这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>\n<h5 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a><em>componentDidMount</em></h5><p>在组件第一次绘制之后，会调用 componentDidMount()，通知组件已经加载完成。这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 componentDidMount()，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发.</p>\n<h5 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a><em>componentWillReceiveProps</em></h5><p>如果组件收到新的属性（props），就会调用 componentWillReceiveProps(),输入参数 nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 this.setState() 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 render() 调用。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillReceiveProps(nextProps) &#123;  </span><br><span class=\"line\">  this.setState(&#123;</span><br><span class=\"line\">    oldProps: nextProps</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a><em>shouldComponentUpdate</em></h5><p>当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate(…)，输入参数 nextProps 和上面的 componentWillReceiveProps 函数一样，nextState 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 true 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>\n<p>默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>\n<h5 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a><em>componentWillUpdate</em></h5><p>如果组件状态或者属性改变，并且上面的 shouldComponentUpdate(…) 返回为 true，就会开始准更新组件，并调用 componentWillUpdate()，输入参数与 shouldComponentUpdate 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了。</p>\n<h5 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a><em>componentDidUpdate</em></h5><p>调用了 render() 更新完成界面之后，会调用 componentDidUpdate() 来得到通知，因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 prevProps 和 prevState。</p>\n<h5 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a><em>componentWillUnmount</em></h5><p>当组件要被从界面上移除的时候，就会调用 componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里，RN 的组件的完整的生命都介绍完了，在回头来看一下前面的图，就比较清晰了，把生命周期的回调函数总结成如下表格：</p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>调用次数</th>\n<th>能否使用 setSate()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getDefaultProps</td>\n<td>1(全局调用一次)</td>\n<td>否</td>\n</tr>\n<tr>\n<td>getInitialState</td>\n<td>1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>render</td>\n<td>&gt;=1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>componentWillReceiveProps</td>\n<td>&gt;=0</td>\n<td>是</td>\n</tr>\n<tr>\n<td>shouldComponentUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUnmount</td>\n<td>1</td>\n<td>否</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN 组件的生命周期整理如下图：</p>","more":"<p><img src=\"https://img.race604.com/3-3-component-lifecycle.jpg\" alt=\"生命周期\"></p>\n<p>如图，可以把组件生命周期大致分为三个阶段：</p>\n<ul>\n<li>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；</li>\n<li>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面；</li>\n<li>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</li>\n</ul>\n<h2 id=\"生命周期回调函数\"><a href=\"#生命周期回调函数\" class=\"headerlink\" title=\"生命周期回调函数\"></a>生命周期回调函数</h2><p>下面来详细介绍生命周期中的各回调函数。</p>\n<h5 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a><em>getDefaultProps</em></h5><p>在组件创建之前，会先调用 getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 getInitialState()，来初始化组件的状态。</p>\n<h5 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a><em>componentWillMount</em></h5><p>然后，准备加载组件，会调用 componentWillMount(), 这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>\n<h5 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a><em>componentDidMount</em></h5><p>在组件第一次绘制之后，会调用 componentDidMount()，通知组件已经加载完成。这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 componentDidMount()，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发.</p>\n<h5 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a><em>componentWillReceiveProps</em></h5><p>如果组件收到新的属性（props），就会调用 componentWillReceiveProps(),输入参数 nextProps 是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。在这个回调函数里面，你可以根据属性的变化，通过调用 this.setState() 来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的 render() 调用。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillReceiveProps(nextProps) &#123;  </span><br><span class=\"line\">  this.setState(&#123;</span><br><span class=\"line\">    oldProps: nextProps</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a><em>shouldComponentUpdate</em></h5><p>当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate(…)，输入参数 nextProps 和上面的 componentWillReceiveProps 函数一样，nextState 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 true 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。</p>\n<p>默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>\n<h5 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a><em>componentWillUpdate</em></h5><p>如果组件状态或者属性改变，并且上面的 shouldComponentUpdate(…) 返回为 true，就会开始准更新组件，并调用 componentWillUpdate()，输入参数与 shouldComponentUpdate 一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了。</p>\n<h5 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a><em>componentDidUpdate</em></h5><p>调用了 render() 更新完成界面之后，会调用 componentDidUpdate() 来得到通知，因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了 prevProps 和 prevState。</p>\n<h5 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a><em>componentWillUnmount</em></h5><p>当组件要被从界面上移除的时候，就会调用 componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等.</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里，RN 的组件的完整的生命都介绍完了，在回头来看一下前面的图，就比较清晰了，把生命周期的回调函数总结成如下表格：</p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>调用次数</th>\n<th>能否使用 setSate()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>getDefaultProps</td>\n<td>1(全局调用一次)</td>\n<td>否</td>\n</tr>\n<tr>\n<td>getInitialState</td>\n<td>1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>render</td>\n<td>&gt;=1</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidMount</td>\n<td>1</td>\n<td>是</td>\n</tr>\n<tr>\n<td>componentWillReceiveProps</td>\n<td>&gt;=0</td>\n<td>是</td>\n</tr>\n<tr>\n<td>shouldComponentUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentDidUpdate</td>\n<td>&gt;=0</td>\n<td>否</td>\n</tr>\n<tr>\n<td>componentWillUnmount</td>\n<td>1</td>\n<td>否</td>\n</tr>\n</tbody></table>"},{"title":"setState","date":"2018-11-27T05:10:53.000Z","_content":"\n\n## setState\n\nreact中的状态state通过 setState() 方法来改变促进页面的重新渲染，但是在使用的时候每个人都会遇到各种不同的问题，我在网上看到很多人说setState的坑，吐槽的人也比较多，类似于下面这种问题，在我刚开始的时候也遇到过：\n\n <!-- more -->\n \n### 1. setState不会立即改变数据\n\n```\n// name is ''\nthis.setState({\n     name: 'myName'\n})\nconsole.log('name is', this.state.name) // 输出 ？？？\n```\n\n这里当然是期望打印出改变后的state值，但是却并不能得到期望的值，为什么会这样呢？因为 setState 是一个异步执行的函数，所以这里输出的依然是改变之前的 state 值，其实 setState 提供给我们两个参数，第二个参数是一个回调函数，所以我们可以通过回调函数来获取到正确的值。\n\n```\nthis.setState({\n    name: 'myName'\n}, () => {\n    console.log(`name is ${this.state.name}`)\n})\n```\n### 2. setState多次，Re-render 一次\n以前刚接触react的时候，我一度认为每次 setState 都会造成一次 re-render ，其实并不是这样：\n```\ncomponentDidMount() {\n    this.setState((prevState, props) => ({count: this.state.count + 1})) // 1\n    this.setState((prevState, props) => ({count: this.state.count + 1})) // 2\n    this.setState((prevState, props) => ({count: this.state.count + 1})) // 3\n    this.setState({name: \"xiaohesong\"}) // 4\n}\nrender() {\n    console.log('render')\n    return(\n\t// ...\n    )\n}\n```\n可以发现，这里打印出 ‘render’ 仅为两次，并不是 4+1 次，为什么？\n我们之前说 `setState` 是一个异步执行的方法，其实是说当我们调用 `setState` 的时候，`setState` 是放在一个队列中异步处理的，也就是说他会把我们这四个 `setState`操作放到一个队列中，然后batch处理。\n```\n  this.setState((prevState, props) => ({count: this.state.count + 1})) // 1\n  this.setState((prevState, props) => ({count: this.state.count + 1})) // 2\n  this.setState((prevState, props) => ({count: this.state.count + 1})) // 3\n  this.setState({name: \"xiaohesong\"}) // 4\n```\n如何批量操作的？？？setState方法是将传入的参数对象或函数返回的对象与现有的state对象进行合并，非常类似于使用Object.assign(prevState, newState)的效果\n```\nObject.assign(state,{count: this.state.count + 1},{count: this.state.count + 1}...{name: \"xiaohesong\"})\n```\n### 3. setState 造成没必要的渲染\n第二点也告诉我们 setState 每次都会造成页面的重新渲染，但是很多时候，有些渲染不是必要的，不必要的渲染有以下几个原因：\n\n+ 新的 state 其实和之前的是一样的。这个问题通常可以通过 shouldComponentUpdate 来解决。\n+ 通常发生改变的 state 是和渲染有关的，但是也有例外。比如，有些数据是根据某些状态来显示的。\n+ 第三，有些 state 和渲染一点关系都没有。有一些 state 可能是和事件、 timer ID 有关的。\n\n#### 总结 ：\n1. setState操作,默认情况下是每次调用, 都会re-render一次,除非你手动shouldComponentUpdate为false. react为了减少rerender的次数,会进行一个浅合并.将多次re-render减少到一次re-render.\n\n2. setState之后,无法立即获取到this.state的值,是因为在setState的时候,他只会把操作放到队列里.\n3. 和渲染无关的状态尽量不要放在 state 中来管理。\n","source":"_posts/setState.md","raw":"---\ntitle: setState\ndate: 2018-11-27 13:10:53\ntags:\n- react\ncategories:\n- react\t\n---\n\n\n## setState\n\nreact中的状态state通过 setState() 方法来改变促进页面的重新渲染，但是在使用的时候每个人都会遇到各种不同的问题，我在网上看到很多人说setState的坑，吐槽的人也比较多，类似于下面这种问题，在我刚开始的时候也遇到过：\n\n <!-- more -->\n \n### 1. setState不会立即改变数据\n\n```\n// name is ''\nthis.setState({\n     name: 'myName'\n})\nconsole.log('name is', this.state.name) // 输出 ？？？\n```\n\n这里当然是期望打印出改变后的state值，但是却并不能得到期望的值，为什么会这样呢？因为 setState 是一个异步执行的函数，所以这里输出的依然是改变之前的 state 值，其实 setState 提供给我们两个参数，第二个参数是一个回调函数，所以我们可以通过回调函数来获取到正确的值。\n\n```\nthis.setState({\n    name: 'myName'\n}, () => {\n    console.log(`name is ${this.state.name}`)\n})\n```\n### 2. setState多次，Re-render 一次\n以前刚接触react的时候，我一度认为每次 setState 都会造成一次 re-render ，其实并不是这样：\n```\ncomponentDidMount() {\n    this.setState((prevState, props) => ({count: this.state.count + 1})) // 1\n    this.setState((prevState, props) => ({count: this.state.count + 1})) // 2\n    this.setState((prevState, props) => ({count: this.state.count + 1})) // 3\n    this.setState({name: \"xiaohesong\"}) // 4\n}\nrender() {\n    console.log('render')\n    return(\n\t// ...\n    )\n}\n```\n可以发现，这里打印出 ‘render’ 仅为两次，并不是 4+1 次，为什么？\n我们之前说 `setState` 是一个异步执行的方法，其实是说当我们调用 `setState` 的时候，`setState` 是放在一个队列中异步处理的，也就是说他会把我们这四个 `setState`操作放到一个队列中，然后batch处理。\n```\n  this.setState((prevState, props) => ({count: this.state.count + 1})) // 1\n  this.setState((prevState, props) => ({count: this.state.count + 1})) // 2\n  this.setState((prevState, props) => ({count: this.state.count + 1})) // 3\n  this.setState({name: \"xiaohesong\"}) // 4\n```\n如何批量操作的？？？setState方法是将传入的参数对象或函数返回的对象与现有的state对象进行合并，非常类似于使用Object.assign(prevState, newState)的效果\n```\nObject.assign(state,{count: this.state.count + 1},{count: this.state.count + 1}...{name: \"xiaohesong\"})\n```\n### 3. setState 造成没必要的渲染\n第二点也告诉我们 setState 每次都会造成页面的重新渲染，但是很多时候，有些渲染不是必要的，不必要的渲染有以下几个原因：\n\n+ 新的 state 其实和之前的是一样的。这个问题通常可以通过 shouldComponentUpdate 来解决。\n+ 通常发生改变的 state 是和渲染有关的，但是也有例外。比如，有些数据是根据某些状态来显示的。\n+ 第三，有些 state 和渲染一点关系都没有。有一些 state 可能是和事件、 timer ID 有关的。\n\n#### 总结 ：\n1. setState操作,默认情况下是每次调用, 都会re-render一次,除非你手动shouldComponentUpdate为false. react为了减少rerender的次数,会进行一个浅合并.将多次re-render减少到一次re-render.\n\n2. setState之后,无法立即获取到this.state的值,是因为在setState的时候,他只会把操作放到队列里.\n3. 和渲染无关的状态尽量不要放在 state 中来管理。\n","slug":"setState","published":1,"updated":"2022-03-17T12:21:16.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w0vvqh00077cdqhfwtebpp","content":"<h2 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h2><p>react中的状态state通过 setState() 方法来改变促进页面的重新渲染，但是在使用的时候每个人都会遇到各种不同的问题，我在网上看到很多人说setState的坑，吐槽的人也比较多，类似于下面这种问题，在我刚开始的时候也遇到过：</p>\n <span id=\"more\"></span>\n<h3 id=\"1-setState不会立即改变数据\"><a href=\"#1-setState不会立即改变数据\" class=\"headerlink\" title=\"1. setState不会立即改变数据\"></a>1. setState不会立即改变数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// name is &#x27;&#x27;</span><br><span class=\"line\">this.setState(&#123;</span><br><span class=\"line\">     name: &#x27;myName&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&#x27;name is&#x27;, this.state.name) // 输出 ？？？</span><br></pre></td></tr></table></figure>\n\n<p>这里当然是期望打印出改变后的state值，但是却并不能得到期望的值，为什么会这样呢？因为 setState 是一个异步执行的函数，所以这里输出的依然是改变之前的 state 值，其实 setState 提供给我们两个参数，第二个参数是一个回调函数，所以我们可以通过回调函数来获取到正确的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.setState(&#123;</span><br><span class=\"line\">    name: &#x27;myName&#x27;</span><br><span class=\"line\">&#125;, () =&gt; &#123;</span><br><span class=\"line\">    console.log(`name is $&#123;this.state.name&#125;`)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-setState多次，Re-render-一次\"><a href=\"#2-setState多次，Re-render-一次\" class=\"headerlink\" title=\"2. setState多次，Re-render 一次\"></a>2. setState多次，Re-render 一次</h3><p>以前刚接触react的时候，我一度认为每次 setState 都会造成一次 re-render ，其实并不是这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 1</span><br><span class=\"line\">    this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 2</span><br><span class=\"line\">    this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 3</span><br><span class=\"line\">    this.setState(&#123;name: &quot;xiaohesong&quot;&#125;) // 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;)</span><br><span class=\"line\">    return(</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，这里打印出 ‘render’ 仅为两次，并不是 4+1 次，为什么？<br>我们之前说 <code>setState</code> 是一个异步执行的方法，其实是说当我们调用 <code>setState</code> 的时候，<code>setState</code> 是放在一个队列中异步处理的，也就是说他会把我们这四个 <code>setState</code>操作放到一个队列中，然后batch处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 1</span><br><span class=\"line\">this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 2</span><br><span class=\"line\">this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 3</span><br><span class=\"line\">this.setState(&#123;name: &quot;xiaohesong&quot;&#125;) // 4</span><br></pre></td></tr></table></figure>\n<p>如何批量操作的？？？setState方法是将传入的参数对象或函数返回的对象与现有的state对象进行合并，非常类似于使用Object.assign(prevState, newState)的效果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.assign(state,&#123;count: this.state.count + 1&#125;,&#123;count: this.state.count + 1&#125;...&#123;name: &quot;xiaohesong&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-setState-造成没必要的渲染\"><a href=\"#3-setState-造成没必要的渲染\" class=\"headerlink\" title=\"3. setState 造成没必要的渲染\"></a>3. setState 造成没必要的渲染</h3><p>第二点也告诉我们 setState 每次都会造成页面的重新渲染，但是很多时候，有些渲染不是必要的，不必要的渲染有以下几个原因：</p>\n<ul>\n<li>新的 state 其实和之前的是一样的。这个问题通常可以通过 shouldComponentUpdate 来解决。</li>\n<li>通常发生改变的 state 是和渲染有关的，但是也有例外。比如，有些数据是根据某些状态来显示的。</li>\n<li>第三，有些 state 和渲染一点关系都没有。有一些 state 可能是和事件、 timer ID 有关的。</li>\n</ul>\n<h4 id=\"总结-：\"><a href=\"#总结-：\" class=\"headerlink\" title=\"总结 ：\"></a>总结 ：</h4><ol>\n<li><p>setState操作,默认情况下是每次调用, 都会re-render一次,除非你手动shouldComponentUpdate为false. react为了减少rerender的次数,会进行一个浅合并.将多次re-render减少到一次re-render.</p>\n</li>\n<li><p>setState之后,无法立即获取到this.state的值,是因为在setState的时候,他只会把操作放到队列里.</p>\n</li>\n<li><p>和渲染无关的状态尽量不要放在 state 中来管理。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h2><p>react中的状态state通过 setState() 方法来改变促进页面的重新渲染，但是在使用的时候每个人都会遇到各种不同的问题，我在网上看到很多人说setState的坑，吐槽的人也比较多，类似于下面这种问题，在我刚开始的时候也遇到过：</p>","more":"<h3 id=\"1-setState不会立即改变数据\"><a href=\"#1-setState不会立即改变数据\" class=\"headerlink\" title=\"1. setState不会立即改变数据\"></a>1. setState不会立即改变数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// name is &#x27;&#x27;</span><br><span class=\"line\">this.setState(&#123;</span><br><span class=\"line\">     name: &#x27;myName&#x27;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&#x27;name is&#x27;, this.state.name) // 输出 ？？？</span><br></pre></td></tr></table></figure>\n\n<p>这里当然是期望打印出改变后的state值，但是却并不能得到期望的值，为什么会这样呢？因为 setState 是一个异步执行的函数，所以这里输出的依然是改变之前的 state 值，其实 setState 提供给我们两个参数，第二个参数是一个回调函数，所以我们可以通过回调函数来获取到正确的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.setState(&#123;</span><br><span class=\"line\">    name: &#x27;myName&#x27;</span><br><span class=\"line\">&#125;, () =&gt; &#123;</span><br><span class=\"line\">    console.log(`name is $&#123;this.state.name&#125;`)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-setState多次，Re-render-一次\"><a href=\"#2-setState多次，Re-render-一次\" class=\"headerlink\" title=\"2. setState多次，Re-render 一次\"></a>2. setState多次，Re-render 一次</h3><p>以前刚接触react的时候，我一度认为每次 setState 都会造成一次 re-render ，其实并不是这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 1</span><br><span class=\"line\">    this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 2</span><br><span class=\"line\">    this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 3</span><br><span class=\"line\">    this.setState(&#123;name: &quot;xiaohesong&quot;&#125;) // 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">    console.log(&#x27;render&#x27;)</span><br><span class=\"line\">    return(</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，这里打印出 ‘render’ 仅为两次，并不是 4+1 次，为什么？<br>我们之前说 <code>setState</code> 是一个异步执行的方法，其实是说当我们调用 <code>setState</code> 的时候，<code>setState</code> 是放在一个队列中异步处理的，也就是说他会把我们这四个 <code>setState</code>操作放到一个队列中，然后batch处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 1</span><br><span class=\"line\">this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 2</span><br><span class=\"line\">this.setState((prevState, props) =&gt; (&#123;count: this.state.count + 1&#125;)) // 3</span><br><span class=\"line\">this.setState(&#123;name: &quot;xiaohesong&quot;&#125;) // 4</span><br></pre></td></tr></table></figure>\n<p>如何批量操作的？？？setState方法是将传入的参数对象或函数返回的对象与现有的state对象进行合并，非常类似于使用Object.assign(prevState, newState)的效果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.assign(state,&#123;count: this.state.count + 1&#125;,&#123;count: this.state.count + 1&#125;...&#123;name: &quot;xiaohesong&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-setState-造成没必要的渲染\"><a href=\"#3-setState-造成没必要的渲染\" class=\"headerlink\" title=\"3. setState 造成没必要的渲染\"></a>3. setState 造成没必要的渲染</h3><p>第二点也告诉我们 setState 每次都会造成页面的重新渲染，但是很多时候，有些渲染不是必要的，不必要的渲染有以下几个原因：</p>\n<ul>\n<li>新的 state 其实和之前的是一样的。这个问题通常可以通过 shouldComponentUpdate 来解决。</li>\n<li>通常发生改变的 state 是和渲染有关的，但是也有例外。比如，有些数据是根据某些状态来显示的。</li>\n<li>第三，有些 state 和渲染一点关系都没有。有一些 state 可能是和事件、 timer ID 有关的。</li>\n</ul>\n<h4 id=\"总结-：\"><a href=\"#总结-：\" class=\"headerlink\" title=\"总结 ：\"></a>总结 ：</h4><ol>\n<li><p>setState操作,默认情况下是每次调用, 都会re-render一次,除非你手动shouldComponentUpdate为false. react为了减少rerender的次数,会进行一个浅合并.将多次re-render减少到一次re-render.</p>\n</li>\n<li><p>setState之后,无法立即获取到this.state的值,是因为在setState的时候,他只会把操作放到队列里.</p>\n</li>\n<li><p>和渲染无关的状态尽量不要放在 state 中来管理。</p>\n</li>\n</ol>"},{"title":"react-native简介","date":"2018-11-05T07:19:45.000Z","type":"tags","_content":"### 用 React 编写移动应用 React Native <img src='https://www.oschina.net/build/oschina/project/stylesheets/imgs/badge_recommend.svg' width=\"20\" height=\"20\"/>\n**ReactNative ** 可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。而且React Native已经用于生产环境——Facebook Groups iOS 应用就是基于它开发的。\n\n <!-- more -->\n![react-native](http://static.oschina.net/uploads/img/201503/28132016_EqCq.jpg)\n\nReact Native的原理是在JavaScript中用React抽象操作系统原生的UI组件，代替DOM元素来渲染，比如以 `<View>` 取代 `<div>`，以`<Image>`替代`<img>`等。\n\n在幕后，React Native在主线程之外，在另一个背景线程里运行JavaScript引擎，两个线程之间通过一批量化的async消息协议来通信（有一个专门的React插件）。\n\nUI方面React Native提供跨平台的类似Flexbox的布局系统，还支持CSS子集。可以用JSX或者普通JavaScript语言，还有[CoffeeScript](https://coffeescript.org/ 'CoffeeScript') 和 [TypeScript](http://www.typescriptlang.org/ 'TypeScript') 来开发。\n\n更好的是，由于基于Web技术，开发起来可以像在浏览器里那样随时在仿真程序中查看应用运行情况，刷新一下就行，无需编译，爽吧。\n\nReact Native比起标准Web开发或原生开发能够带来的三大好处：\n1.手势识别：基于Web技术（HTML5/JavaScript）构建的移动应用经常被抱怨缺乏及时响应。而基于原生UI的React Native能避免这些问题从而实现实时响应。\n2.原生组件：使用HTML5/JavaScript实现的组件比起原生组件总是让人感觉差一截，而React Native由于采用了原生UI组件自然没有此问题。\n3.样式和布局：iOS、Android和基于Web的应用各自有不同的样式和布局机制。React Native通过一个基于FlexBox的布局引擎在所有移动平台上实现了一致的跨平台样式和布局方案。\n\n触摸事件处理：\n\n```\nimport React, { Component } from 'react';\nimport { ScrollView, TouchableHighlight, Text, StyleSheet } from 'react-native';\n\nclass TouchDemo extends Component{\n  render() {\n    return (\n      <ScrollView>\n        <TouchableHighlight onPress={() => console.log('pressed')}>\n          <Text style={styles.txt}>Proper Touch Handling</Text>\n        </TouchableHighlight>\n      </ScrollView>\n    );\n  },\n};\nconst styles = StyleSheet.create({\n  txt:{\n    fontSize: 14,\n    color: '#333333'\n  }\n})\n\n```\n","source":"_posts/react-native简介.md","raw":"---\ntitle: react-native简介\ndate: 2018-11-05 15:19:45\ntype: 'tags'\ntags:                 \n- react-native\ncategories:\n- react-native\n---\n### 用 React 编写移动应用 React Native <img src='https://www.oschina.net/build/oschina/project/stylesheets/imgs/badge_recommend.svg' width=\"20\" height=\"20\"/>\n**ReactNative ** 可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。而且React Native已经用于生产环境——Facebook Groups iOS 应用就是基于它开发的。\n\n <!-- more -->\n![react-native](http://static.oschina.net/uploads/img/201503/28132016_EqCq.jpg)\n\nReact Native的原理是在JavaScript中用React抽象操作系统原生的UI组件，代替DOM元素来渲染，比如以 `<View>` 取代 `<div>`，以`<Image>`替代`<img>`等。\n\n在幕后，React Native在主线程之外，在另一个背景线程里运行JavaScript引擎，两个线程之间通过一批量化的async消息协议来通信（有一个专门的React插件）。\n\nUI方面React Native提供跨平台的类似Flexbox的布局系统，还支持CSS子集。可以用JSX或者普通JavaScript语言，还有[CoffeeScript](https://coffeescript.org/ 'CoffeeScript') 和 [TypeScript](http://www.typescriptlang.org/ 'TypeScript') 来开发。\n\n更好的是，由于基于Web技术，开发起来可以像在浏览器里那样随时在仿真程序中查看应用运行情况，刷新一下就行，无需编译，爽吧。\n\nReact Native比起标准Web开发或原生开发能够带来的三大好处：\n1.手势识别：基于Web技术（HTML5/JavaScript）构建的移动应用经常被抱怨缺乏及时响应。而基于原生UI的React Native能避免这些问题从而实现实时响应。\n2.原生组件：使用HTML5/JavaScript实现的组件比起原生组件总是让人感觉差一截，而React Native由于采用了原生UI组件自然没有此问题。\n3.样式和布局：iOS、Android和基于Web的应用各自有不同的样式和布局机制。React Native通过一个基于FlexBox的布局引擎在所有移动平台上实现了一致的跨平台样式和布局方案。\n\n触摸事件处理：\n\n```\nimport React, { Component } from 'react';\nimport { ScrollView, TouchableHighlight, Text, StyleSheet } from 'react-native';\n\nclass TouchDemo extends Component{\n  render() {\n    return (\n      <ScrollView>\n        <TouchableHighlight onPress={() => console.log('pressed')}>\n          <Text style={styles.txt}>Proper Touch Handling</Text>\n        </TouchableHighlight>\n      </ScrollView>\n    );\n  },\n};\nconst styles = StyleSheet.create({\n  txt:{\n    fontSize: 14,\n    color: '#333333'\n  }\n})\n\n```\n","slug":"react-native简介","published":1,"updated":"2022-03-17T12:21:16.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w0vvqm00087cdq62ps49zo","content":"<h3 id=\"用-React-编写移动应用-React-Native\"><a href=\"#用-React-编写移动应用-React-Native\" class=\"headerlink\" title=\"用 React 编写移动应用 React Native \"></a>用 React 编写移动应用 React Native <img src='https://www.oschina.net/build/oschina/project/stylesheets/imgs/badge_recommend.svg' width=\"20\" height=\"20\"/></h3><p>**ReactNative ** 可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。而且React Native已经用于生产环境——Facebook Groups iOS 应用就是基于它开发的。</p>\n <span id=\"more\"></span>\n<p><img src=\"http://static.oschina.net/uploads/img/201503/28132016_EqCq.jpg\" alt=\"react-native\"></p>\n<p>React Native的原理是在JavaScript中用React抽象操作系统原生的UI组件，代替DOM元素来渲染，比如以 <code>&lt;View&gt;</code> 取代 <code>&lt;div&gt;</code>，以<code>&lt;Image&gt;</code>替代<code>&lt;img&gt;</code>等。</p>\n<p>在幕后，React Native在主线程之外，在另一个背景线程里运行JavaScript引擎，两个线程之间通过一批量化的async消息协议来通信（有一个专门的React插件）。</p>\n<p>UI方面React Native提供跨平台的类似Flexbox的布局系统，还支持CSS子集。可以用JSX或者普通JavaScript语言，还有<a href=\"https://coffeescript.org/\" title=\"CoffeeScript\">CoffeeScript</a> 和 <a href=\"http://www.typescriptlang.org/\" title=\"TypeScript\">TypeScript</a> 来开发。</p>\n<p>更好的是，由于基于Web技术，开发起来可以像在浏览器里那样随时在仿真程序中查看应用运行情况，刷新一下就行，无需编译，爽吧。</p>\n<p>React Native比起标准Web开发或原生开发能够带来的三大好处：<br>1.手势识别：基于Web技术（HTML5/JavaScript）构建的移动应用经常被抱怨缺乏及时响应。而基于原生UI的React Native能避免这些问题从而实现实时响应。<br>2.原生组件：使用HTML5/JavaScript实现的组件比起原生组件总是让人感觉差一截，而React Native由于采用了原生UI组件自然没有此问题。<br>3.样式和布局：iOS、Android和基于Web的应用各自有不同的样式和布局机制。React Native通过一个基于FlexBox的布局引擎在所有移动平台上实现了一致的跨平台样式和布局方案。</p>\n<p>触摸事件处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; ScrollView, TouchableHighlight, Text, StyleSheet &#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class TouchDemo extends Component&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ScrollView&gt;</span><br><span class=\"line\">        &lt;TouchableHighlight onPress=&#123;() =&gt; console.log(&#x27;pressed&#x27;)&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;styles.txt&#125;&gt;Proper Touch Handling&lt;/Text&gt;</span><br><span class=\"line\">        &lt;/TouchableHighlight&gt;</span><br><span class=\"line\">      &lt;/ScrollView&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  txt:&#123;</span><br><span class=\"line\">    fontSize: 14,</span><br><span class=\"line\">    color: &#x27;#333333&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"用-React-编写移动应用-React-Native\"><a href=\"#用-React-编写移动应用-React-Native\" class=\"headerlink\" title=\"用 React 编写移动应用 React Native \"></a>用 React 编写移动应用 React Native <img src='https://www.oschina.net/build/oschina/project/stylesheets/imgs/badge_recommend.svg' width=\"20\" height=\"20\"/></h3><p>**ReactNative ** 可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。而且React Native已经用于生产环境——Facebook Groups iOS 应用就是基于它开发的。</p>","more":"<p><img src=\"http://static.oschina.net/uploads/img/201503/28132016_EqCq.jpg\" alt=\"react-native\"></p>\n<p>React Native的原理是在JavaScript中用React抽象操作系统原生的UI组件，代替DOM元素来渲染，比如以 <code>&lt;View&gt;</code> 取代 <code>&lt;div&gt;</code>，以<code>&lt;Image&gt;</code>替代<code>&lt;img&gt;</code>等。</p>\n<p>在幕后，React Native在主线程之外，在另一个背景线程里运行JavaScript引擎，两个线程之间通过一批量化的async消息协议来通信（有一个专门的React插件）。</p>\n<p>UI方面React Native提供跨平台的类似Flexbox的布局系统，还支持CSS子集。可以用JSX或者普通JavaScript语言，还有<a href=\"https://coffeescript.org/\" title=\"CoffeeScript\">CoffeeScript</a> 和 <a href=\"http://www.typescriptlang.org/\" title=\"TypeScript\">TypeScript</a> 来开发。</p>\n<p>更好的是，由于基于Web技术，开发起来可以像在浏览器里那样随时在仿真程序中查看应用运行情况，刷新一下就行，无需编译，爽吧。</p>\n<p>React Native比起标准Web开发或原生开发能够带来的三大好处：<br>1.手势识别：基于Web技术（HTML5/JavaScript）构建的移动应用经常被抱怨缺乏及时响应。而基于原生UI的React Native能避免这些问题从而实现实时响应。<br>2.原生组件：使用HTML5/JavaScript实现的组件比起原生组件总是让人感觉差一截，而React Native由于采用了原生UI组件自然没有此问题。<br>3.样式和布局：iOS、Android和基于Web的应用各自有不同的样式和布局机制。React Native通过一个基于FlexBox的布局引擎在所有移动平台上实现了一致的跨平台样式和布局方案。</p>\n<p>触摸事件处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">import &#123; ScrollView, TouchableHighlight, Text, StyleSheet &#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">class TouchDemo extends Component&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ScrollView&gt;</span><br><span class=\"line\">        &lt;TouchableHighlight onPress=&#123;() =&gt; console.log(&#x27;pressed&#x27;)&#125;&gt;</span><br><span class=\"line\">          &lt;Text style=&#123;styles.txt&#125;&gt;Proper Touch Handling&lt;/Text&gt;</span><br><span class=\"line\">        &lt;/TouchableHighlight&gt;</span><br><span class=\"line\">      &lt;/ScrollView&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const styles = StyleSheet.create(&#123;</span><br><span class=\"line\">  txt:&#123;</span><br><span class=\"line\">    fontSize: 14,</span><br><span class=\"line\">    color: &#x27;#333333&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"state-hook","date":"2018-11-27T08:58:47.000Z","type":"tags","_content":"\n## state-hook\n\n在之前的的hook 介绍里有一段代码:\n\n    import { useState } from 'react';\n    ​\n    function Example() {\n      // Declare a new state variable, which we'll call \"count\"\n      const [count, setCount] = useState(0);\n    ​\n      return (\n        <div>\n          <p>You clicked {count} times</p>\n          <button onClick={() => setCount(count + 1)}>\n            Click me\n          </button>\n        </div>\n      );\n    }\n\n我们将通过将此代码与等效的类示例进行比较来开始学习`Hooks`。\n\n## 等价的类示例\n看下面的这段代码，你会觉得熟悉：\n```\nclass Example extends Component{\n   constructor(props) {\n      super(props);\n      this.state = {\n        count: 0\n      }\n   }\n\n   render(){\n      return (\n          <div>\n          <p>You clicked {this.state.count} times</p>\n            <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n              Click me\n            </button>\n          </div>\n      )\n   }\n}\n```\n状态以`{count：0}`开始，当用户通过调用this.setState单击按钮时，我们会增加state.count。我们将在整个页面中使用此类的片段。\n\n> **注意** 你可能想知道为什么我们在这里使用计数器而不是更现实的例子。这是为了帮助我们专注于`API`，同时我们仍在使用`Hooks`迈出第一步。\n\n## Hooks和函数组件\n提醒一下，React中的函数组件如下所示：\n\n    const Example = (props) => {\n      // You can use Hooks here!\n      return <div />;\n    }\n或者是下面这样的：\n\n    function Example(props) {\n      // You can use Hooks here!\n      return <div />;\n    }\n\n 你可能以前将这些称为“无状态组件”。我们现在介绍的这些中具有使用`React`状态的能力，所以我们更喜欢名称`function components`。\n\n `Hook`在`class`内 不起 作用。但是你可以使用它们而不是编写类。\n\n## 什么是Hook\n我们的新示例首先从`React`导入`useState Hook`：\n```\nimport { useState } from 'react';\nfunction Example() {\n    // ...\n}\n```\n**什么是Hook?** `Hook`是一种特殊功能，可让你“挂钩”`React`功能。例如，`useState`是一个`Hook`，允许你将`React`状态添加到函数组件。我们稍后会学习其他的`Hooks`。\n\n我什么时候使用`Hook`? 如果你编写一个函数组件并意识到你需要为它添加一些状态，那么之前你必须将它转换为一个类。但是现在，你可以在现有功能组件中使用`Hook`。我们现在要做到这一点！\n\n> **注意：** 关于在何处可以使用Hook并且不能在组件中使用`Hook`，有一些特殊规则。我们将在[“钩子规则”]()中学习它们。\n\n## 声明一个状态变量\n在`class`组建中，我们声明一个状态需要像下面这样：\n\n    class Example extends Component {\n        constructor(props) {\n            super(props);\n            this.state = {\n                count: 0\n            }\n        }\n        // ...\n    }\n在函数组件中，我们没有`this`，所以我们不能分配或读取`this.state`。相反，我们直接在组件内部调用`useState Hook`：\n\n    import { useState } from 'react';\n    ​\n    function Example() {\n      const [count, setCount] = useState(0);\n      // ...\n    }\n**调用`useState`有什么作用？** 他声明了一个\"状态变量\"。我们的变量叫做`count`，但我们可以称之为其他任何东西，比如`banana`。这是一种在函数调用之间“保留”某些值的方法 - `useState`是一种使用`this.state`在类中提供的完全相同功能的新方法。通常，当函数退出时变量“消失”但`React`保留状态变量。\n\n**我们传递给`useState`的参数是什么？** `useState Hook`的唯一参数是初始状态。与类不同，状态不必是对象。他可以是任何我们需要的内容，比如数字，字符串等。在我们的示例中，我们只需要一个数字来表示用户点击的次数，因此将0作为变量的初始状态。（如果我们想在状态中存储两个不同的值，我们将调用`useState`两次。）\n\n`useState`返回的是什么？ 它返回一对值：当前状态和更新状态的函数。这就是我们编写`const [count，setCount] = useState(0)`的原因。这与类中的 `this.state.count`和`this.setState`类似，只不过现在它们是成对的。\n\n现在我们知道了`useState Hook`的作用，我们的例子应该更有意义\n\n    import { useState } from 'react';\n    ​\n    function Example() {\n      const [count, setCount] = useState(0);\n      // ...\n    }\n\n我们声明一个名为`count`的状态变量，并将其设置为0。`React`将记住重新渲染之间的当前值，并为我们的函数提供最新的值。如果我们想要更新当前`count`，我们可以调用`setCount`。\n\n> **注意** 你可能想知道：为什么`useState`没有命名为`createState`？“`create`”不会非常准确，因为状态仅在我们的组件第一次呈现时创建。在下一次渲染期间，useState为我们提供了当前状态。否则它根本不会是“状态”！`Hook`名称总是从`use`开始也是有原因的。我们将在后来的`rules hooks`中了解原因。\n\n## 读取状态\n当我们想要在类中显示当前计数时，我们读取`this.state.count`：\n\n    <p>You clicked {this.state.count} times</p>\n在函数中，我们可以直接使用`count`：\n\n    <p>You clicked {count} times</p>\n\n## 更新状态\n在一个类中，我们需要调用`this.setState`来更新`count`状态:\n\n    <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n        Click me\n    </button>\n在函数中，我们已经将`setCount`和`count`作为变量，因此我们不需要`this`：\n\n    <button onClick={() => setCount(count + 1)}>\n        Click me\n    </button>\n\n## 概括\n现在让我们回顾一下我们逐行学习的内容并检查我们的理解。\n\n     import { useState } from 'react';\n\n     function Example() {\n        const [count, setCount] = useState(0);\n\n        return (\n           <div>\n             <p>You clicked {count} times</p>\n               <button onClick={() => setCount(count + 1)}>\n                    Click me\n               </button>\n           </div>\n          );\n        }\n\n+ **第1行：** 我们从`React`导入`useState Hook`。它允许我们将本地状态保存在功能组件中。\n\n+ **第2行：** 在`Example`组件中，我们通过调用`useState Hook`来声明一个新的状态变量。它返回一对值，我们给它们命名。我们调用变量`count`，因为它包含按钮点击次数。\n我们通过传递`0`作为唯一的`useState`参数将其初始化为零。第二个返回的项本身就是一个函数。它允许我们更新`count`，因此我们将其命名为`setCount`。\n\n+ **第9行：** 当用户点击时，我们使用新值调用`setCount`。然后，`React`将重新呈现`Example`组件，并将新`count`值传递给它。\n\n一开始看起来似乎有很多东西需要考虑。不要急于求成！如果你在解释有不了解的，请再次查看上面的代码并尝试从上到下阅读。我们保证，一旦你试图“忘记”状态如何在`class`上工作，并以新的角度看待这个代码，它就会有意义。\n\n### **提示：方括号意味着什么？**\n当我们声明一个状态变量时，你可能已经注意到方括号：\n\n    const [count, setCount] = useState(0);\n\n左侧的名称不是`React API`的一部分。你可以命名自己觉得合适的状态变量：\n\n    const [fruit, setFruit] = useState('banana');\n\n 此`JavaScript`语法称为“数组解构”。这意味着我们正在创建两个新变量`fruit`和`setFruit`，其中`fruit`设置为`useState`返回的第一个值，`setFruit`是第二个。等同于下面的代码：\n\n    var fruitStateVariable = useState('banana');\n    var fruit = fruitStateVariable[0];\n    var setFruit = fruitStateVariable[1];\n\n当我们使用`useState`声明一个状态变量时，它返回一对 - 一个包含两个项的数组。第一项是当前值，第二项是允许我们更新第一项值的函数。使用`[0]`和`[1]`访问它们有点令人困惑，因为它们具有特定含义。这就是我们使用数组解构的原因。\n\n> **注意:** 你可能很好奇`React`如何知道哪个组件`useState`对应，因为我们没有将这样的任何内容传递给`React`。我们将在FAQ部分回答[这个问题](https://reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components)和许多其他问题。\n\n### 提示：使用多个状态变量\n将状态变量声明为一对`[something，setSomething]`也很方便，因为如果我们想要使用多个状态变量，它可以让我们为不同的状态变量赋予不同的名称：\n\n    function ExampleWithManyStates() {\n      // Declare multiple state variables!\n      const [age, setAge] = useState(42);\n      const [fruit, setFruit] = useState('banana');\n      const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n      //...\n    }\n在上面的组件中，我们将`age`，`fruit`和`todos`作为局部变量，我们可以单独更新它们：\n\n    function handleOrangeClick() {\n        // Similar to this.setState({ fruit: 'orange' })\n        setFruit('orange');\n      }\n你 **不必使用** 许多状态变量。 状态变量可以很好地保存对象和数组，因此仍然可以将相关数据组合在一起。但是，与类中的this.setState不同，**更新状态变量总是替换它而不是合并它。**\n","source":"_posts/state-hook.md","raw":"---\ntitle: state-hook\ndate: 2018-11-27 16:58:47\ntype: 'tags'\ntags:\n- react\n- react-hooks\ncategories:\n- react\n- react-hooks\n---\n\n## state-hook\n\n在之前的的hook 介绍里有一段代码:\n\n    import { useState } from 'react';\n    ​\n    function Example() {\n      // Declare a new state variable, which we'll call \"count\"\n      const [count, setCount] = useState(0);\n    ​\n      return (\n        <div>\n          <p>You clicked {count} times</p>\n          <button onClick={() => setCount(count + 1)}>\n            Click me\n          </button>\n        </div>\n      );\n    }\n\n我们将通过将此代码与等效的类示例进行比较来开始学习`Hooks`。\n\n## 等价的类示例\n看下面的这段代码，你会觉得熟悉：\n```\nclass Example extends Component{\n   constructor(props) {\n      super(props);\n      this.state = {\n        count: 0\n      }\n   }\n\n   render(){\n      return (\n          <div>\n          <p>You clicked {this.state.count} times</p>\n            <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n              Click me\n            </button>\n          </div>\n      )\n   }\n}\n```\n状态以`{count：0}`开始，当用户通过调用this.setState单击按钮时，我们会增加state.count。我们将在整个页面中使用此类的片段。\n\n> **注意** 你可能想知道为什么我们在这里使用计数器而不是更现实的例子。这是为了帮助我们专注于`API`，同时我们仍在使用`Hooks`迈出第一步。\n\n## Hooks和函数组件\n提醒一下，React中的函数组件如下所示：\n\n    const Example = (props) => {\n      // You can use Hooks here!\n      return <div />;\n    }\n或者是下面这样的：\n\n    function Example(props) {\n      // You can use Hooks here!\n      return <div />;\n    }\n\n 你可能以前将这些称为“无状态组件”。我们现在介绍的这些中具有使用`React`状态的能力，所以我们更喜欢名称`function components`。\n\n `Hook`在`class`内 不起 作用。但是你可以使用它们而不是编写类。\n\n## 什么是Hook\n我们的新示例首先从`React`导入`useState Hook`：\n```\nimport { useState } from 'react';\nfunction Example() {\n    // ...\n}\n```\n**什么是Hook?** `Hook`是一种特殊功能，可让你“挂钩”`React`功能。例如，`useState`是一个`Hook`，允许你将`React`状态添加到函数组件。我们稍后会学习其他的`Hooks`。\n\n我什么时候使用`Hook`? 如果你编写一个函数组件并意识到你需要为它添加一些状态，那么之前你必须将它转换为一个类。但是现在，你可以在现有功能组件中使用`Hook`。我们现在要做到这一点！\n\n> **注意：** 关于在何处可以使用Hook并且不能在组件中使用`Hook`，有一些特殊规则。我们将在[“钩子规则”]()中学习它们。\n\n## 声明一个状态变量\n在`class`组建中，我们声明一个状态需要像下面这样：\n\n    class Example extends Component {\n        constructor(props) {\n            super(props);\n            this.state = {\n                count: 0\n            }\n        }\n        // ...\n    }\n在函数组件中，我们没有`this`，所以我们不能分配或读取`this.state`。相反，我们直接在组件内部调用`useState Hook`：\n\n    import { useState } from 'react';\n    ​\n    function Example() {\n      const [count, setCount] = useState(0);\n      // ...\n    }\n**调用`useState`有什么作用？** 他声明了一个\"状态变量\"。我们的变量叫做`count`，但我们可以称之为其他任何东西，比如`banana`。这是一种在函数调用之间“保留”某些值的方法 - `useState`是一种使用`this.state`在类中提供的完全相同功能的新方法。通常，当函数退出时变量“消失”但`React`保留状态变量。\n\n**我们传递给`useState`的参数是什么？** `useState Hook`的唯一参数是初始状态。与类不同，状态不必是对象。他可以是任何我们需要的内容，比如数字，字符串等。在我们的示例中，我们只需要一个数字来表示用户点击的次数，因此将0作为变量的初始状态。（如果我们想在状态中存储两个不同的值，我们将调用`useState`两次。）\n\n`useState`返回的是什么？ 它返回一对值：当前状态和更新状态的函数。这就是我们编写`const [count，setCount] = useState(0)`的原因。这与类中的 `this.state.count`和`this.setState`类似，只不过现在它们是成对的。\n\n现在我们知道了`useState Hook`的作用，我们的例子应该更有意义\n\n    import { useState } from 'react';\n    ​\n    function Example() {\n      const [count, setCount] = useState(0);\n      // ...\n    }\n\n我们声明一个名为`count`的状态变量，并将其设置为0。`React`将记住重新渲染之间的当前值，并为我们的函数提供最新的值。如果我们想要更新当前`count`，我们可以调用`setCount`。\n\n> **注意** 你可能想知道：为什么`useState`没有命名为`createState`？“`create`”不会非常准确，因为状态仅在我们的组件第一次呈现时创建。在下一次渲染期间，useState为我们提供了当前状态。否则它根本不会是“状态”！`Hook`名称总是从`use`开始也是有原因的。我们将在后来的`rules hooks`中了解原因。\n\n## 读取状态\n当我们想要在类中显示当前计数时，我们读取`this.state.count`：\n\n    <p>You clicked {this.state.count} times</p>\n在函数中，我们可以直接使用`count`：\n\n    <p>You clicked {count} times</p>\n\n## 更新状态\n在一个类中，我们需要调用`this.setState`来更新`count`状态:\n\n    <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n        Click me\n    </button>\n在函数中，我们已经将`setCount`和`count`作为变量，因此我们不需要`this`：\n\n    <button onClick={() => setCount(count + 1)}>\n        Click me\n    </button>\n\n## 概括\n现在让我们回顾一下我们逐行学习的内容并检查我们的理解。\n\n     import { useState } from 'react';\n\n     function Example() {\n        const [count, setCount] = useState(0);\n\n        return (\n           <div>\n             <p>You clicked {count} times</p>\n               <button onClick={() => setCount(count + 1)}>\n                    Click me\n               </button>\n           </div>\n          );\n        }\n\n+ **第1行：** 我们从`React`导入`useState Hook`。它允许我们将本地状态保存在功能组件中。\n\n+ **第2行：** 在`Example`组件中，我们通过调用`useState Hook`来声明一个新的状态变量。它返回一对值，我们给它们命名。我们调用变量`count`，因为它包含按钮点击次数。\n我们通过传递`0`作为唯一的`useState`参数将其初始化为零。第二个返回的项本身就是一个函数。它允许我们更新`count`，因此我们将其命名为`setCount`。\n\n+ **第9行：** 当用户点击时，我们使用新值调用`setCount`。然后，`React`将重新呈现`Example`组件，并将新`count`值传递给它。\n\n一开始看起来似乎有很多东西需要考虑。不要急于求成！如果你在解释有不了解的，请再次查看上面的代码并尝试从上到下阅读。我们保证，一旦你试图“忘记”状态如何在`class`上工作，并以新的角度看待这个代码，它就会有意义。\n\n### **提示：方括号意味着什么？**\n当我们声明一个状态变量时，你可能已经注意到方括号：\n\n    const [count, setCount] = useState(0);\n\n左侧的名称不是`React API`的一部分。你可以命名自己觉得合适的状态变量：\n\n    const [fruit, setFruit] = useState('banana');\n\n 此`JavaScript`语法称为“数组解构”。这意味着我们正在创建两个新变量`fruit`和`setFruit`，其中`fruit`设置为`useState`返回的第一个值，`setFruit`是第二个。等同于下面的代码：\n\n    var fruitStateVariable = useState('banana');\n    var fruit = fruitStateVariable[0];\n    var setFruit = fruitStateVariable[1];\n\n当我们使用`useState`声明一个状态变量时，它返回一对 - 一个包含两个项的数组。第一项是当前值，第二项是允许我们更新第一项值的函数。使用`[0]`和`[1]`访问它们有点令人困惑，因为它们具有特定含义。这就是我们使用数组解构的原因。\n\n> **注意:** 你可能很好奇`React`如何知道哪个组件`useState`对应，因为我们没有将这样的任何内容传递给`React`。我们将在FAQ部分回答[这个问题](https://reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components)和许多其他问题。\n\n### 提示：使用多个状态变量\n将状态变量声明为一对`[something，setSomething]`也很方便，因为如果我们想要使用多个状态变量，它可以让我们为不同的状态变量赋予不同的名称：\n\n    function ExampleWithManyStates() {\n      // Declare multiple state variables!\n      const [age, setAge] = useState(42);\n      const [fruit, setFruit] = useState('banana');\n      const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n      //...\n    }\n在上面的组件中，我们将`age`，`fruit`和`todos`作为局部变量，我们可以单独更新它们：\n\n    function handleOrangeClick() {\n        // Similar to this.setState({ fruit: 'orange' })\n        setFruit('orange');\n      }\n你 **不必使用** 许多状态变量。 状态变量可以很好地保存对象和数组，因此仍然可以将相关数据组合在一起。但是，与类中的this.setState不同，**更新状态变量总是替换它而不是合并它。**\n","slug":"state-hook","published":1,"updated":"2022-03-17T12:21:16.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w0vvqo00097cdq2w1l06yj","content":"<h2 id=\"state-hook\"><a href=\"#state-hook\" class=\"headerlink\" title=\"state-hook\"></a>state-hook</h2><p>在之前的的hook 介绍里有一段代码:</p>\n<pre><code>import &#123; useState &#125; from &#39;react&#39;;\n​\nfunction Example() &#123;\n  // Declare a new state variable, which we&#39;ll call &quot;count&quot;\n  const [count, setCount] = useState(0);\n​\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<p>我们将通过将此代码与等效的类示例进行比较来开始学习<code>Hooks</code>。</p>\n<h2 id=\"等价的类示例\"><a href=\"#等价的类示例\" class=\"headerlink\" title=\"等价的类示例\"></a>等价的类示例</h2><p>看下面的这段代码，你会觉得熟悉：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Example extends Component&#123;</span><br><span class=\"line\">   constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.state = &#123;</span><br><span class=\"line\">        count: 0</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   render()&#123;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">          &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class=\"line\">              Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>状态以<code>&#123;count：0&#125;</code>开始，当用户通过调用this.setState单击按钮时，我们会增加state.count。我们将在整个页面中使用此类的片段。</p>\n<blockquote>\n<p><strong>注意</strong> 你可能想知道为什么我们在这里使用计数器而不是更现实的例子。这是为了帮助我们专注于<code>API</code>，同时我们仍在使用<code>Hooks</code>迈出第一步。</p>\n</blockquote>\n<h2 id=\"Hooks和函数组件\"><a href=\"#Hooks和函数组件\" class=\"headerlink\" title=\"Hooks和函数组件\"></a>Hooks和函数组件</h2><p>提醒一下，React中的函数组件如下所示：</p>\n<pre><code>const Example = (props) =&gt; &#123;\n  // You can use Hooks here!\n  return &lt;div /&gt;;\n&#125;\n</code></pre>\n<p>或者是下面这样的：</p>\n<pre><code>function Example(props) &#123;\n  // You can use Hooks here!\n  return &lt;div /&gt;;\n&#125;\n</code></pre>\n<p> 你可能以前将这些称为“无状态组件”。我们现在介绍的这些中具有使用<code>React</code>状态的能力，所以我们更喜欢名称<code>function components</code>。</p>\n<p> <code>Hook</code>在<code>class</code>内 不起 作用。但是你可以使用它们而不是编写类。</p>\n<h2 id=\"什么是Hook\"><a href=\"#什么是Hook\" class=\"headerlink\" title=\"什么是Hook\"></a>什么是Hook</h2><p>我们的新示例首先从<code>React</code>导入<code>useState Hook</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>什么是Hook?</strong> <code>Hook</code>是一种特殊功能，可让你“挂钩”<code>React</code>功能。例如，<code>useState</code>是一个<code>Hook</code>，允许你将<code>React</code>状态添加到函数组件。我们稍后会学习其他的<code>Hooks</code>。</p>\n<p>我什么时候使用<code>Hook</code>? 如果你编写一个函数组件并意识到你需要为它添加一些状态，那么之前你必须将它转换为一个类。但是现在，你可以在现有功能组件中使用<code>Hook</code>。我们现在要做到这一点！</p>\n<blockquote>\n<p><strong>注意：</strong> 关于在何处可以使用Hook并且不能在组件中使用<code>Hook</code>，有一些特殊规则。我们将在<a href=\"\">“钩子规则”</a>中学习它们。</p>\n</blockquote>\n<h2 id=\"声明一个状态变量\"><a href=\"#声明一个状态变量\" class=\"headerlink\" title=\"声明一个状态变量\"></a>声明一个状态变量</h2><p>在<code>class</code>组建中，我们声明一个状态需要像下面这样：</p>\n<pre><code>class Example extends Component &#123;\n    constructor(props) &#123;\n        super(props);\n        this.state = &#123;\n            count: 0\n        &#125;\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<p>在函数组件中，我们没有<code>this</code>，所以我们不能分配或读取<code>this.state</code>。相反，我们直接在组件内部调用<code>useState Hook</code>：</p>\n<pre><code>import &#123; useState &#125; from &#39;react&#39;;\n​\nfunction Example() &#123;\n  const [count, setCount] = useState(0);\n  // ...\n&#125;\n</code></pre>\n<p><strong>调用<code>useState</code>有什么作用？</strong> 他声明了一个”状态变量”。我们的变量叫做<code>count</code>，但我们可以称之为其他任何东西，比如<code>banana</code>。这是一种在函数调用之间“保留”某些值的方法 - <code>useState</code>是一种使用<code>this.state</code>在类中提供的完全相同功能的新方法。通常，当函数退出时变量“消失”但<code>React</code>保留状态变量。</p>\n<p><strong>我们传递给<code>useState</code>的参数是什么？</strong> <code>useState Hook</code>的唯一参数是初始状态。与类不同，状态不必是对象。他可以是任何我们需要的内容，比如数字，字符串等。在我们的示例中，我们只需要一个数字来表示用户点击的次数，因此将0作为变量的初始状态。（如果我们想在状态中存储两个不同的值，我们将调用<code>useState</code>两次。）</p>\n<p><code>useState</code>返回的是什么？ 它返回一对值：当前状态和更新状态的函数。这就是我们编写<code>const [count，setCount] = useState(0)</code>的原因。这与类中的 <code>this.state.count</code>和<code>this.setState</code>类似，只不过现在它们是成对的。</p>\n<p>现在我们知道了<code>useState Hook</code>的作用，我们的例子应该更有意义</p>\n<pre><code>import &#123; useState &#125; from &#39;react&#39;;\n​\nfunction Example() &#123;\n  const [count, setCount] = useState(0);\n  // ...\n&#125;\n</code></pre>\n<p>我们声明一个名为<code>count</code>的状态变量，并将其设置为0。<code>React</code>将记住重新渲染之间的当前值，并为我们的函数提供最新的值。如果我们想要更新当前<code>count</code>，我们可以调用<code>setCount</code>。</p>\n<blockquote>\n<p><strong>注意</strong> 你可能想知道：为什么<code>useState</code>没有命名为<code>createState</code>？“<code>create</code>”不会非常准确，因为状态仅在我们的组件第一次呈现时创建。在下一次渲染期间，useState为我们提供了当前状态。否则它根本不会是“状态”！<code>Hook</code>名称总是从<code>use</code>开始也是有原因的。我们将在后来的<code>rules hooks</code>中了解原因。</p>\n</blockquote>\n<h2 id=\"读取状态\"><a href=\"#读取状态\" class=\"headerlink\" title=\"读取状态\"></a>读取状态</h2><p>当我们想要在类中显示当前计数时，我们读取<code>this.state.count</code>：</p>\n<pre><code>&lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;\n</code></pre>\n<p>在函数中，我们可以直接使用<code>count</code>：</p>\n<pre><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n</code></pre>\n<h2 id=\"更新状态\"><a href=\"#更新状态\" class=\"headerlink\" title=\"更新状态\"></a>更新状态</h2><p>在一个类中，我们需要调用<code>this.setState</code>来更新<code>count</code>状态:</p>\n<pre><code>&lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;\n    Click me\n&lt;/button&gt;\n</code></pre>\n<p>在函数中，我们已经将<code>setCount</code>和<code>count</code>作为变量，因此我们不需要<code>this</code>：</p>\n<pre><code>&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;\n    Click me\n&lt;/button&gt;\n</code></pre>\n<h2 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h2><p>现在让我们回顾一下我们逐行学习的内容并检查我们的理解。</p>\n<pre><code> import &#123; useState &#125; from &#39;react&#39;;\n\n function Example() &#123;\n    const [count, setCount] = useState(0);\n\n    return (\n       &lt;div&gt;\n         &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n           &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;\n                Click me\n           &lt;/button&gt;\n       &lt;/div&gt;\n      );\n    &#125;\n</code></pre>\n<ul>\n<li><p><strong>第1行：</strong> 我们从<code>React</code>导入<code>useState Hook</code>。它允许我们将本地状态保存在功能组件中。</p>\n</li>\n<li><p><strong>第2行：</strong> 在<code>Example</code>组件中，我们通过调用<code>useState Hook</code>来声明一个新的状态变量。它返回一对值，我们给它们命名。我们调用变量<code>count</code>，因为它包含按钮点击次数。<br>我们通过传递<code>0</code>作为唯一的<code>useState</code>参数将其初始化为零。第二个返回的项本身就是一个函数。它允许我们更新<code>count</code>，因此我们将其命名为<code>setCount</code>。</p>\n</li>\n<li><p><strong>第9行：</strong> 当用户点击时，我们使用新值调用<code>setCount</code>。然后，<code>React</code>将重新呈现<code>Example</code>组件，并将新<code>count</code>值传递给它。</p>\n</li>\n</ul>\n<p>一开始看起来似乎有很多东西需要考虑。不要急于求成！如果你在解释有不了解的，请再次查看上面的代码并尝试从上到下阅读。我们保证，一旦你试图“忘记”状态如何在<code>class</code>上工作，并以新的角度看待这个代码，它就会有意义。</p>\n<h3 id=\"提示：方括号意味着什么？\"><a href=\"#提示：方括号意味着什么？\" class=\"headerlink\" title=\"提示：方括号意味着什么？\"></a><strong>提示：方括号意味着什么？</strong></h3><p>当我们声明一个状态变量时，你可能已经注意到方括号：</p>\n<pre><code>const [count, setCount] = useState(0);\n</code></pre>\n<p>左侧的名称不是<code>React API</code>的一部分。你可以命名自己觉得合适的状态变量：</p>\n<pre><code>const [fruit, setFruit] = useState(&#39;banana&#39;);\n</code></pre>\n<p> 此<code>JavaScript</code>语法称为“数组解构”。这意味着我们正在创建两个新变量<code>fruit</code>和<code>setFruit</code>，其中<code>fruit</code>设置为<code>useState</code>返回的第一个值，<code>setFruit</code>是第二个。等同于下面的代码：</p>\n<pre><code>var fruitStateVariable = useState(&#39;banana&#39;);\nvar fruit = fruitStateVariable[0];\nvar setFruit = fruitStateVariable[1];\n</code></pre>\n<p>当我们使用<code>useState</code>声明一个状态变量时，它返回一对 - 一个包含两个项的数组。第一项是当前值，第二项是允许我们更新第一项值的函数。使用<code>[0]</code>和<code>[1]</code>访问它们有点令人困惑，因为它们具有特定含义。这就是我们使用数组解构的原因。</p>\n<blockquote>\n<p><strong>注意:</strong> 你可能很好奇<code>React</code>如何知道哪个组件<code>useState</code>对应，因为我们没有将这样的任何内容传递给<code>React</code>。我们将在FAQ部分回答<a href=\"https://reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components\">这个问题</a>和许多其他问题。</p>\n</blockquote>\n<h3 id=\"提示：使用多个状态变量\"><a href=\"#提示：使用多个状态变量\" class=\"headerlink\" title=\"提示：使用多个状态变量\"></a>提示：使用多个状态变量</h3><p>将状态变量声明为一对<code>[something，setSomething]</code>也很方便，因为如果我们想要使用多个状态变量，它可以让我们为不同的状态变量赋予不同的名称：</p>\n<pre><code>function ExampleWithManyStates() &#123;\n  // Declare multiple state variables!\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState(&#39;banana&#39;);\n  const [todos, setTodos] = useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);\n  //...\n&#125;\n</code></pre>\n<p>在上面的组件中，我们将<code>age</code>，<code>fruit</code>和<code>todos</code>作为局部变量，我们可以单独更新它们：</p>\n<pre><code>function handleOrangeClick() &#123;\n    // Similar to this.setState(&#123; fruit: &#39;orange&#39; &#125;)\n    setFruit(&#39;orange&#39;);\n  &#125;\n</code></pre>\n<p>你 <strong>不必使用</strong> 许多状态变量。 状态变量可以很好地保存对象和数组，因此仍然可以将相关数据组合在一起。但是，与类中的this.setState不同，<strong>更新状态变量总是替换它而不是合并它。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"state-hook\"><a href=\"#state-hook\" class=\"headerlink\" title=\"state-hook\"></a>state-hook</h2><p>在之前的的hook 介绍里有一段代码:</p>\n<pre><code>import &#123; useState &#125; from &#39;react&#39;;\n​\nfunction Example() &#123;\n  // Declare a new state variable, which we&#39;ll call &quot;count&quot;\n  const [count, setCount] = useState(0);\n​\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n&#125;\n</code></pre>\n<p>我们将通过将此代码与等效的类示例进行比较来开始学习<code>Hooks</code>。</p>\n<h2 id=\"等价的类示例\"><a href=\"#等价的类示例\" class=\"headerlink\" title=\"等价的类示例\"></a>等价的类示例</h2><p>看下面的这段代码，你会觉得熟悉：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Example extends Component&#123;</span><br><span class=\"line\">   constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.state = &#123;</span><br><span class=\"line\">        count: 0</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   render()&#123;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">          &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class=\"line\">              Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>状态以<code>&#123;count：0&#125;</code>开始，当用户通过调用this.setState单击按钮时，我们会增加state.count。我们将在整个页面中使用此类的片段。</p>\n<blockquote>\n<p><strong>注意</strong> 你可能想知道为什么我们在这里使用计数器而不是更现实的例子。这是为了帮助我们专注于<code>API</code>，同时我们仍在使用<code>Hooks</code>迈出第一步。</p>\n</blockquote>\n<h2 id=\"Hooks和函数组件\"><a href=\"#Hooks和函数组件\" class=\"headerlink\" title=\"Hooks和函数组件\"></a>Hooks和函数组件</h2><p>提醒一下，React中的函数组件如下所示：</p>\n<pre><code>const Example = (props) =&gt; &#123;\n  // You can use Hooks here!\n  return &lt;div /&gt;;\n&#125;\n</code></pre>\n<p>或者是下面这样的：</p>\n<pre><code>function Example(props) &#123;\n  // You can use Hooks here!\n  return &lt;div /&gt;;\n&#125;\n</code></pre>\n<p> 你可能以前将这些称为“无状态组件”。我们现在介绍的这些中具有使用<code>React</code>状态的能力，所以我们更喜欢名称<code>function components</code>。</p>\n<p> <code>Hook</code>在<code>class</code>内 不起 作用。但是你可以使用它们而不是编写类。</p>\n<h2 id=\"什么是Hook\"><a href=\"#什么是Hook\" class=\"headerlink\" title=\"什么是Hook\"></a>什么是Hook</h2><p>我们的新示例首先从<code>React</code>导入<code>useState Hook</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>什么是Hook?</strong> <code>Hook</code>是一种特殊功能，可让你“挂钩”<code>React</code>功能。例如，<code>useState</code>是一个<code>Hook</code>，允许你将<code>React</code>状态添加到函数组件。我们稍后会学习其他的<code>Hooks</code>。</p>\n<p>我什么时候使用<code>Hook</code>? 如果你编写一个函数组件并意识到你需要为它添加一些状态，那么之前你必须将它转换为一个类。但是现在，你可以在现有功能组件中使用<code>Hook</code>。我们现在要做到这一点！</p>\n<blockquote>\n<p><strong>注意：</strong> 关于在何处可以使用Hook并且不能在组件中使用<code>Hook</code>，有一些特殊规则。我们将在<a href=\"\">“钩子规则”</a>中学习它们。</p>\n</blockquote>\n<h2 id=\"声明一个状态变量\"><a href=\"#声明一个状态变量\" class=\"headerlink\" title=\"声明一个状态变量\"></a>声明一个状态变量</h2><p>在<code>class</code>组建中，我们声明一个状态需要像下面这样：</p>\n<pre><code>class Example extends Component &#123;\n    constructor(props) &#123;\n        super(props);\n        this.state = &#123;\n            count: 0\n        &#125;\n    &#125;\n    // ...\n&#125;\n</code></pre>\n<p>在函数组件中，我们没有<code>this</code>，所以我们不能分配或读取<code>this.state</code>。相反，我们直接在组件内部调用<code>useState Hook</code>：</p>\n<pre><code>import &#123; useState &#125; from &#39;react&#39;;\n​\nfunction Example() &#123;\n  const [count, setCount] = useState(0);\n  // ...\n&#125;\n</code></pre>\n<p><strong>调用<code>useState</code>有什么作用？</strong> 他声明了一个”状态变量”。我们的变量叫做<code>count</code>，但我们可以称之为其他任何东西，比如<code>banana</code>。这是一种在函数调用之间“保留”某些值的方法 - <code>useState</code>是一种使用<code>this.state</code>在类中提供的完全相同功能的新方法。通常，当函数退出时变量“消失”但<code>React</code>保留状态变量。</p>\n<p><strong>我们传递给<code>useState</code>的参数是什么？</strong> <code>useState Hook</code>的唯一参数是初始状态。与类不同，状态不必是对象。他可以是任何我们需要的内容，比如数字，字符串等。在我们的示例中，我们只需要一个数字来表示用户点击的次数，因此将0作为变量的初始状态。（如果我们想在状态中存储两个不同的值，我们将调用<code>useState</code>两次。）</p>\n<p><code>useState</code>返回的是什么？ 它返回一对值：当前状态和更新状态的函数。这就是我们编写<code>const [count，setCount] = useState(0)</code>的原因。这与类中的 <code>this.state.count</code>和<code>this.setState</code>类似，只不过现在它们是成对的。</p>\n<p>现在我们知道了<code>useState Hook</code>的作用，我们的例子应该更有意义</p>\n<pre><code>import &#123; useState &#125; from &#39;react&#39;;\n​\nfunction Example() &#123;\n  const [count, setCount] = useState(0);\n  // ...\n&#125;\n</code></pre>\n<p>我们声明一个名为<code>count</code>的状态变量，并将其设置为0。<code>React</code>将记住重新渲染之间的当前值，并为我们的函数提供最新的值。如果我们想要更新当前<code>count</code>，我们可以调用<code>setCount</code>。</p>\n<blockquote>\n<p><strong>注意</strong> 你可能想知道：为什么<code>useState</code>没有命名为<code>createState</code>？“<code>create</code>”不会非常准确，因为状态仅在我们的组件第一次呈现时创建。在下一次渲染期间，useState为我们提供了当前状态。否则它根本不会是“状态”！<code>Hook</code>名称总是从<code>use</code>开始也是有原因的。我们将在后来的<code>rules hooks</code>中了解原因。</p>\n</blockquote>\n<h2 id=\"读取状态\"><a href=\"#读取状态\" class=\"headerlink\" title=\"读取状态\"></a>读取状态</h2><p>当我们想要在类中显示当前计数时，我们读取<code>this.state.count</code>：</p>\n<pre><code>&lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;\n</code></pre>\n<p>在函数中，我们可以直接使用<code>count</code>：</p>\n<pre><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n</code></pre>\n<h2 id=\"更新状态\"><a href=\"#更新状态\" class=\"headerlink\" title=\"更新状态\"></a>更新状态</h2><p>在一个类中，我们需要调用<code>this.setState</code>来更新<code>count</code>状态:</p>\n<pre><code>&lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;\n    Click me\n&lt;/button&gt;\n</code></pre>\n<p>在函数中，我们已经将<code>setCount</code>和<code>count</code>作为变量，因此我们不需要<code>this</code>：</p>\n<pre><code>&lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;\n    Click me\n&lt;/button&gt;\n</code></pre>\n<h2 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h2><p>现在让我们回顾一下我们逐行学习的内容并检查我们的理解。</p>\n<pre><code> import &#123; useState &#125; from &#39;react&#39;;\n\n function Example() &#123;\n    const [count, setCount] = useState(0);\n\n    return (\n       &lt;div&gt;\n         &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;\n           &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;\n                Click me\n           &lt;/button&gt;\n       &lt;/div&gt;\n      );\n    &#125;\n</code></pre>\n<ul>\n<li><p><strong>第1行：</strong> 我们从<code>React</code>导入<code>useState Hook</code>。它允许我们将本地状态保存在功能组件中。</p>\n</li>\n<li><p><strong>第2行：</strong> 在<code>Example</code>组件中，我们通过调用<code>useState Hook</code>来声明一个新的状态变量。它返回一对值，我们给它们命名。我们调用变量<code>count</code>，因为它包含按钮点击次数。<br>我们通过传递<code>0</code>作为唯一的<code>useState</code>参数将其初始化为零。第二个返回的项本身就是一个函数。它允许我们更新<code>count</code>，因此我们将其命名为<code>setCount</code>。</p>\n</li>\n<li><p><strong>第9行：</strong> 当用户点击时，我们使用新值调用<code>setCount</code>。然后，<code>React</code>将重新呈现<code>Example</code>组件，并将新<code>count</code>值传递给它。</p>\n</li>\n</ul>\n<p>一开始看起来似乎有很多东西需要考虑。不要急于求成！如果你在解释有不了解的，请再次查看上面的代码并尝试从上到下阅读。我们保证，一旦你试图“忘记”状态如何在<code>class</code>上工作，并以新的角度看待这个代码，它就会有意义。</p>\n<h3 id=\"提示：方括号意味着什么？\"><a href=\"#提示：方括号意味着什么？\" class=\"headerlink\" title=\"提示：方括号意味着什么？\"></a><strong>提示：方括号意味着什么？</strong></h3><p>当我们声明一个状态变量时，你可能已经注意到方括号：</p>\n<pre><code>const [count, setCount] = useState(0);\n</code></pre>\n<p>左侧的名称不是<code>React API</code>的一部分。你可以命名自己觉得合适的状态变量：</p>\n<pre><code>const [fruit, setFruit] = useState(&#39;banana&#39;);\n</code></pre>\n<p> 此<code>JavaScript</code>语法称为“数组解构”。这意味着我们正在创建两个新变量<code>fruit</code>和<code>setFruit</code>，其中<code>fruit</code>设置为<code>useState</code>返回的第一个值，<code>setFruit</code>是第二个。等同于下面的代码：</p>\n<pre><code>var fruitStateVariable = useState(&#39;banana&#39;);\nvar fruit = fruitStateVariable[0];\nvar setFruit = fruitStateVariable[1];\n</code></pre>\n<p>当我们使用<code>useState</code>声明一个状态变量时，它返回一对 - 一个包含两个项的数组。第一项是当前值，第二项是允许我们更新第一项值的函数。使用<code>[0]</code>和<code>[1]</code>访问它们有点令人困惑，因为它们具有特定含义。这就是我们使用数组解构的原因。</p>\n<blockquote>\n<p><strong>注意:</strong> 你可能很好奇<code>React</code>如何知道哪个组件<code>useState</code>对应，因为我们没有将这样的任何内容传递给<code>React</code>。我们将在FAQ部分回答<a href=\"https://reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components\">这个问题</a>和许多其他问题。</p>\n</blockquote>\n<h3 id=\"提示：使用多个状态变量\"><a href=\"#提示：使用多个状态变量\" class=\"headerlink\" title=\"提示：使用多个状态变量\"></a>提示：使用多个状态变量</h3><p>将状态变量声明为一对<code>[something，setSomething]</code>也很方便，因为如果我们想要使用多个状态变量，它可以让我们为不同的状态变量赋予不同的名称：</p>\n<pre><code>function ExampleWithManyStates() &#123;\n  // Declare multiple state variables!\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState(&#39;banana&#39;);\n  const [todos, setTodos] = useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);\n  //...\n&#125;\n</code></pre>\n<p>在上面的组件中，我们将<code>age</code>，<code>fruit</code>和<code>todos</code>作为局部变量，我们可以单独更新它们：</p>\n<pre><code>function handleOrangeClick() &#123;\n    // Similar to this.setState(&#123; fruit: &#39;orange&#39; &#125;)\n    setFruit(&#39;orange&#39;);\n  &#125;\n</code></pre>\n<p>你 <strong>不必使用</strong> 许多状态变量。 状态变量可以很好地保存对象和数组，因此仍然可以将相关数据组合在一起。但是，与类中的this.setState不同，<strong>更新状态变量总是替换它而不是合并它。</strong></p>\n"},{"title":"Effect-Hook","date":"2018-11-27T05:22:17.000Z","type":"tags","_content":"## effect-hook\n\n`Effect Hook` 可以使得你在函数组件中执行一些带有副作用的方法。\n\n <!-- more -->\n```\nimport {useState, useEffect} from 'react';\nfunction Example (){\n  const [count, setCount] = useState(0);\n  useEffect(()=>{\n    document.title = `You click ${count} times`\n  });\n  \n  return(\n    <div>\n        <p> you click {count} times </p>\n        <button onClick={() => setCount(count + 1)}>点击我</button>\n    </div>\n  )\n}\n```\n上面这段代码是基于上个 [state hook计数器的例子](http://www.baidu.com) 的例子，但是我们现在添加了新的功能，我么讲文档的标题设置为自定义消息，包含了点击次数。\n\n数据获取，设置订阅及先手动更改 `React` 组件中的 `DOM` 都是副作用的示例。无论你是否习惯与将这些操作成为“副作用”或者仅仅是“效果”，但之前你可能已经在组件中执行了这些操作。\n>  **提示：** 如果你熟悉`React`类组件生命周期方法，你就可以将`useEffect Hook`视为`componentDidMount`,`componentDidUpdate`和`componentWillUnmount`的组合。\n\nReact组件中有两种常见的副作用：那些需要清理的副作用和不需要清理的副作用。让我们详细的看一下两者的区别。\n\n----\n## 无需清理的副作用\n有时，我们希望在`React`更新`DOM`之后运行一些额外的代码。网络请求， 手动改变`DOM`和日志记录是不需要清理的效果（副作用，简称“效果”）的常见示例。我们这样说是因为我们可以运行他们并立即忘记他们。让我们比较一下`class`和`hooks`是如何让我们表达这样的副作用。\n\n### 使用class的例子\n在`react`类组件中，`render`方法本身不应该导致副作用。这太早了，我们通常希望`React`更新`DOM`之后执行我们的效果。这就是为啥在`React`类中，我们将副作用放到`componentDidMount`和`componentDidUpdate`中。看我们的例子，这是一个`React`计数器类的组件，它在react对DOM进行更改后立即更新文档的标题。\n\n```\nimport React,{Component} from 'react';\n\nexport default class Example extends Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            count: 0\n        };\n    }\n    \n    componentDidMount() {\n        document.title = `You click ${this.state.count} times`\n    }\n    \n    componentDidUpdate() {\n        document.title = `You clicked ${this.state.count} times`;\n    }\n    \n    render() {\n        return (\n          <div>\n            <p>You clicked {this.state.count} times</p>\n            <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n              Click me\n            </button>\n          </div>\n        );\n  }\n}\n```\n请注意**我们如何在类中复制这两个生命周期方法之间的代码**\n这是因为在许多的情况下，我们希望执行相同的副作用，无论组件是刚安装还是已经更新。从概念上讲，我们希望它在每次渲染之后发生，但是在React类组件中没有这样的方法（render方法应该避免更重要）。我们可以提取一个单独的方法，但是我们仍然需要在这两个地方调用它。\n\n现在让我们回头再看看我们如何使用`useEffect Hook`做同样的事情。\n\n`useEffect`**有什么作用？**\n通过使用这个Hook，你告诉React你的组件需要在渲染后执行某些操作。React将记住你传递的函数（我们将其称为“效果”），并在执行DOM更新后稍后调用它。在这个效果中，我们设置文档标题，但我们也可以执行数据提取或调用其他命令式API。\n\n**为什么在组件内调用`useEffect`？** \n在组件中使用`useEffect`让我们可以直接从效果中访问状态变量（如count或任何道具）。我们不需要特殊的API来读取它 - 它已经在函数范围内了。Hooks拥抱`JavaScript`**闭包**，并避免在JavaScript已经提供解决方案的情况下引入特定于React的API。\n\n**每次渲染后useEffect都会运行吗？**\n是的。默认情况下，它在第一次渲染之后和每次更新之后运行。 （我们稍后会讨论如何自定义它。）你可能会发现更容易认为效果发生在“渲染之后”，而不是考虑“挂载”和“更新”。React保证DOM在运行‘效果’时已更新。\n\n### 详细说明\n现在我们对这个`hook`更加的了解了，那再看看下面这个例子：\n```\nfunction Example() {\n    const[count, setCount] = useState(0);\n    \n    useEffect(() => {\n        document.title = `You clicked ${count} times`;\n    });\n}    \n```\n我们声明了`count`状态变量，然后告诉`React`我们需要使用效果。我们将一个函数传递给`useEffect Hook`，这个函数式就是效果（副作用）。在我们的效果中，我们使用`document.title`浏览器`API`设置文档标题。我们可以读取效果中的最新`count`，因为它在我们的函数范围内。当`React`渲染我们的组件时，它会记住我们是用的效果，然后在更新`DOM`后运行我们的效果。每次渲染都会发生这种情况，包括第一次渲染。\n\n> **注意：** 与`componentDidMount`或`componentDidUpdate`不同，使用`useEffect`的效果不会阻止浏览器更新屏幕。这使应用感觉更具响应性。大多数效果不需要同步发生。在他们这样做的不常见情况下（例如测量布局），有一个单独的`useLayoutEffect Hook`，其`API`与`useEffect`相同。\n\n## 需要清理的副作用\n之前，我们研究了如何表达不需要任何清理的副作用。但是，有些效果需要清理。例如，我们可能希望设置对某些外部数据源的订阅。在这种情况下，清理是非常重要的，这样我们就不会引入内存泄漏！让我们比较一下我们如何使用类和`Hooks`来实现它。\n### 使用 **`class`**的例子\n在`React`类中，通常会在`componentDidMount`中设置订阅，并在`componentWillUnmount`中清除它。例如，假设我们有一个ChatAPI`模块，可以让我们订阅朋友的在线状态。以下是我们如何使用类订阅和显示该状态：\n```\nclass FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n        isOnline: null \n    };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n​\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n​\n  render() {\n    if (this.state.isOnline === null) {\n      return 'Loading...';\n    }\n    return this.state.isOnline ? 'Online' : 'Offline';\n  }\n}\n```\n请注意`componentDidMount`和`componentWillUnmount`如何相互作用。生命周期方法迫使我们拆分这个逻辑，即使它们中的概念代码都与相同的效果有关。\n\n> **注意：** 眼尖的你可能会注意到这个例子还需要一个`componentDidUpdate`方法才能完全正确。我们暂时忽略这一点，但会在本页的后面部分再回过头来讨论它。\n\n### 使用**`hooks`**的例子\n你可能认为我们需要单独的效果来执行清理。但是添加和删除订阅的代码是如此紧密相关，以至于`useEffect`旨在将它保持在一起。如果你的效果返回一个函数，`React`将在清理时运行它：\n```\nimport { useState, useEffect } from 'react';\n​\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n​\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n​\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // 指定如何在这种效果之后清理\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n​\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n```\n\n**为什么我们从效果中返回一个函数？** 这是效果的可选清理机制。每个效果都可能返回一个在它之后清理的函数。这使我们可以保持添加和删除彼此接近的订阅的逻辑。\n\n**React什么时候清理效果？** 当组件卸载时，React执行清理。但是，正如我们之前所了解的那样，效果会针对每个渲染运行而不仅仅是一次。这就是React在下次运行效果之前还清除前一渲染效果的原因。我们将讨论为什么这有助于避免错误以及如何在以后发生性能问题时选择退出此行为。\n> **注意:** 我们不必从效果中返回命名函数。我们在这里只是为了说明才加的命名，但你可以返回箭头函数。\n\n## 概述\n我们已经了解到useEffect让我们在组件渲染后表达不同类型的副作用。某些效果可能需要清理，因此它们返回一个函数：\n```\nuseEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n});\n```\n其他效果可能没有清理阶段，也不会返回任何内容。比如：\n```\nuseEffect(() => {\n    document.title = `You clicked ${count} times`;\n});\n```\n如果你觉得你对Effect Hook的工作方式有了很好的把握，或者你感到不知所措，那么现在就可以跳转到关于Hooks规则。\n\n---\n## 使用效果的提示\n我们将继续深入了解使用`React`用户可能会产生好奇心的`useEffect`的某些方面。\n> **提示：使用多重效果分离问题**\n\n这是一个组合了前面示例中的计数器和朋友状态指示器逻辑的组件:\n```\nclass FriendStatusWithCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0, isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n​\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n  // ...\n```\n请注意设置 `document.title` 的逻辑如何在`componentDidMount` 和`componentDidUpdate` 之间拆分。订阅逻辑也在`componentDidMount` 和 `componentWillUnmount`之间传播。`componentDidMount` 包含两个任务的代码。\n\n那么，`Hooks`如何解决这个问题呢？就像你可以多次使用状态挂钩一样，你也可以使用多种效果。这让我们将不相关的逻辑分成不同的效果：\n```\nfunction FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n​\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n​\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n  // ...\n}\n```\n**`Hooks`**允许我们根据它正在做的事情而不是生命周期方法名称来拆分代码。 React将按照指定的顺序应用组件使用的每个效果。\n\n**说明：为什么效果在每个更新上运行**\n如果你习惯了类，你可能想知道为什么每次重新渲染后效果的清理阶段都会发生，而不是在卸载过程中只发生一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建更少bug的组件。\n\n在上面介绍了一个示例FriendStatus组件，该组件显示朋友是否在线。我们的类从this.props读取friend.id，在组件挂载后订阅朋友状态，并在卸载期间取消订阅：\n```\ncomponentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n```\n**但是如果friend prop在组件出现在屏幕上时发生了变化，会发生什么？** 我们的组件将继续显示不同朋友的在线状态。这是一个错误。卸载时我们还会导致内存泄漏或崩溃，因为取消订阅会使用错误的朋友ID。\n\n在类组件中，我们需要添加componentDidUpdate来处理这种情况:\n\n```\ncomponentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentDidUpdate(prevProps) {\n    // 取消之前订阅的朋友\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    // 订阅下一个朋友\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n  \n```  \n\t\t\n忘记正确处理`componentDidUpdate`是`React`应用程序中常见的`bug`漏洞。\n现在考虑使用Hooks的这个组件的版本：\n\n\t\n\tfunction FriendStatus(props) {\n\t  // ...\n\t  useEffect(() => {\n\t\tChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n\t\treturn () => {\n\t\t  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n\t\t};\n\t  });\n\n它不会受到这个bug的影响。 （但我们也没有对它做任何改动。）\n\n没有用于处理更新的特殊代码，因为默认情况下useEffect会处理它们。它会在应用下一个效果之前清除之前的效果。为了说明这一点，这里是一个订阅和取消订阅调用的序列，该组件可以随着时间的推移产生：\n\n\t// Mount with { friend: { id: 100 } } props\n\tChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect\n\t​\n\t// Update with { friend: { id: 200 } } props\n\tChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\n\tChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect\n\t​\n\t// Update with { friend: { id: 300 } } props\n\tChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\n\tChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect\n\t​\n\t// Unmount\n\tChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\n\t\n此行为默认确保一致性，并防止由于缺少更新逻辑而导致类组件中常见的错误。\n\n**提示：通过跳过效果优化性能**\n\n在某些情况下，在每次渲染后清理或应用效果可能会产生性能问题。在类组件中，我们可以通过在`componentDidUpdate`中编写与`prevProps`或`prevState`的额外比较来解决这个问题：\n\n\tcomponentDidUpdate(prevProps, prevState) {\n\t  if (prevState.count !== this.state.count) {\n\t\tdocument.title = `You clicked ${this.state.count} times`;\n\t  }\n\t}\n\n这个要求很常见，它被内置到`useEffect Hook` API中。如果在重新渲染之间没有更改某些值，则可以告诉`React`跳过应用效果。为此，将数组作为可选的第二个参数传递给useEffect：\n\t\n\tuseEffect(() => {\n\t  document.title = `You clicked ${count} times`;\n\t}, [count]); // 当count改变的时候回再次运行这个效果\n\t\n在上面的例子中，我们传递`[count]`作为第二个参数。这是什么意思？如果 `count` 为5，然后我们的组件重新渲染，`count`仍然等于5，则`React`将比较前一个渲染的[5]和下一个渲染的[5]。因为数组中的所有项都是相同的（`5 === 5`），所以`React`会跳过这个效果。这是我们的优化。\n\n当我们使用`count`更新为6渲染时，React会将前一渲染中[5]数组中的项目与下一渲染中[6]数组中的项目进行比较。这次，`React`将重新运行效果，因为`5！== 6`。**如果数组中有多个项目，`React`将重新运行效果，即使其中只有一个不同。**\n\n这也适用于具有清理阶段的效果：\n\n\tuseEffect(() => {\n\t  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n\t  return () => {\n\t\tChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n\t  };\n\t}, [props.friend.id]); // 只有朋友id改变重新订阅\n\n将来， 第二个参数可能会通过构建时转换自动添加。\n\n> **注意:** 如果使用此优化，请确保该数组包含外部作用域中随时间变化且效果使用的任何值，换句话说就是要在这个效果函数里有意义。 否则，代码将引用先前渲染中的旧值。我们还将讨论`Hooks API`参考中的其他优化选项。 \n\n> 如果要**运行效果并仅将其清理一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传递。** 这告诉React你的效果不依赖于来自props或 state的任何值，所以它永远不需要重新运行。这不作为特殊情况处理 - 它直接遵循输入数组的工作方式。虽然传递[]更接近熟悉的`componentDidMount`和 `componentWillUnmount`生命周期，但我们建议不要将它作为一种习惯，因为它经常会导致错误，除非你明确你自己在做什么， 如上所述。 不要忘记`React`推迟运行`useEffect`直到浏览器绘制完成后，所以做额外的工作不是问题。  \n","source":"_posts/Effect-Hook.md","raw":"---\ntitle: Effect-Hook\ndate: 2018-11-27 13:22:17\ntype: 'tags'\ntags:\n- react\n- react-hooks\ncategories:\n- react\t\n- react-hooks\n---\n## effect-hook\n\n`Effect Hook` 可以使得你在函数组件中执行一些带有副作用的方法。\n\n <!-- more -->\n```\nimport {useState, useEffect} from 'react';\nfunction Example (){\n  const [count, setCount] = useState(0);\n  useEffect(()=>{\n    document.title = `You click ${count} times`\n  });\n  \n  return(\n    <div>\n        <p> you click {count} times </p>\n        <button onClick={() => setCount(count + 1)}>点击我</button>\n    </div>\n  )\n}\n```\n上面这段代码是基于上个 [state hook计数器的例子](http://www.baidu.com) 的例子，但是我们现在添加了新的功能，我么讲文档的标题设置为自定义消息，包含了点击次数。\n\n数据获取，设置订阅及先手动更改 `React` 组件中的 `DOM` 都是副作用的示例。无论你是否习惯与将这些操作成为“副作用”或者仅仅是“效果”，但之前你可能已经在组件中执行了这些操作。\n>  **提示：** 如果你熟悉`React`类组件生命周期方法，你就可以将`useEffect Hook`视为`componentDidMount`,`componentDidUpdate`和`componentWillUnmount`的组合。\n\nReact组件中有两种常见的副作用：那些需要清理的副作用和不需要清理的副作用。让我们详细的看一下两者的区别。\n\n----\n## 无需清理的副作用\n有时，我们希望在`React`更新`DOM`之后运行一些额外的代码。网络请求， 手动改变`DOM`和日志记录是不需要清理的效果（副作用，简称“效果”）的常见示例。我们这样说是因为我们可以运行他们并立即忘记他们。让我们比较一下`class`和`hooks`是如何让我们表达这样的副作用。\n\n### 使用class的例子\n在`react`类组件中，`render`方法本身不应该导致副作用。这太早了，我们通常希望`React`更新`DOM`之后执行我们的效果。这就是为啥在`React`类中，我们将副作用放到`componentDidMount`和`componentDidUpdate`中。看我们的例子，这是一个`React`计数器类的组件，它在react对DOM进行更改后立即更新文档的标题。\n\n```\nimport React,{Component} from 'react';\n\nexport default class Example extends Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            count: 0\n        };\n    }\n    \n    componentDidMount() {\n        document.title = `You click ${this.state.count} times`\n    }\n    \n    componentDidUpdate() {\n        document.title = `You clicked ${this.state.count} times`;\n    }\n    \n    render() {\n        return (\n          <div>\n            <p>You clicked {this.state.count} times</p>\n            <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n              Click me\n            </button>\n          </div>\n        );\n  }\n}\n```\n请注意**我们如何在类中复制这两个生命周期方法之间的代码**\n这是因为在许多的情况下，我们希望执行相同的副作用，无论组件是刚安装还是已经更新。从概念上讲，我们希望它在每次渲染之后发生，但是在React类组件中没有这样的方法（render方法应该避免更重要）。我们可以提取一个单独的方法，但是我们仍然需要在这两个地方调用它。\n\n现在让我们回头再看看我们如何使用`useEffect Hook`做同样的事情。\n\n`useEffect`**有什么作用？**\n通过使用这个Hook，你告诉React你的组件需要在渲染后执行某些操作。React将记住你传递的函数（我们将其称为“效果”），并在执行DOM更新后稍后调用它。在这个效果中，我们设置文档标题，但我们也可以执行数据提取或调用其他命令式API。\n\n**为什么在组件内调用`useEffect`？** \n在组件中使用`useEffect`让我们可以直接从效果中访问状态变量（如count或任何道具）。我们不需要特殊的API来读取它 - 它已经在函数范围内了。Hooks拥抱`JavaScript`**闭包**，并避免在JavaScript已经提供解决方案的情况下引入特定于React的API。\n\n**每次渲染后useEffect都会运行吗？**\n是的。默认情况下，它在第一次渲染之后和每次更新之后运行。 （我们稍后会讨论如何自定义它。）你可能会发现更容易认为效果发生在“渲染之后”，而不是考虑“挂载”和“更新”。React保证DOM在运行‘效果’时已更新。\n\n### 详细说明\n现在我们对这个`hook`更加的了解了，那再看看下面这个例子：\n```\nfunction Example() {\n    const[count, setCount] = useState(0);\n    \n    useEffect(() => {\n        document.title = `You clicked ${count} times`;\n    });\n}    \n```\n我们声明了`count`状态变量，然后告诉`React`我们需要使用效果。我们将一个函数传递给`useEffect Hook`，这个函数式就是效果（副作用）。在我们的效果中，我们使用`document.title`浏览器`API`设置文档标题。我们可以读取效果中的最新`count`，因为它在我们的函数范围内。当`React`渲染我们的组件时，它会记住我们是用的效果，然后在更新`DOM`后运行我们的效果。每次渲染都会发生这种情况，包括第一次渲染。\n\n> **注意：** 与`componentDidMount`或`componentDidUpdate`不同，使用`useEffect`的效果不会阻止浏览器更新屏幕。这使应用感觉更具响应性。大多数效果不需要同步发生。在他们这样做的不常见情况下（例如测量布局），有一个单独的`useLayoutEffect Hook`，其`API`与`useEffect`相同。\n\n## 需要清理的副作用\n之前，我们研究了如何表达不需要任何清理的副作用。但是，有些效果需要清理。例如，我们可能希望设置对某些外部数据源的订阅。在这种情况下，清理是非常重要的，这样我们就不会引入内存泄漏！让我们比较一下我们如何使用类和`Hooks`来实现它。\n### 使用 **`class`**的例子\n在`React`类中，通常会在`componentDidMount`中设置订阅，并在`componentWillUnmount`中清除它。例如，假设我们有一个ChatAPI`模块，可以让我们订阅朋友的在线状态。以下是我们如何使用类订阅和显示该状态：\n```\nclass FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n        isOnline: null \n    };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n​\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n​\n  render() {\n    if (this.state.isOnline === null) {\n      return 'Loading...';\n    }\n    return this.state.isOnline ? 'Online' : 'Offline';\n  }\n}\n```\n请注意`componentDidMount`和`componentWillUnmount`如何相互作用。生命周期方法迫使我们拆分这个逻辑，即使它们中的概念代码都与相同的效果有关。\n\n> **注意：** 眼尖的你可能会注意到这个例子还需要一个`componentDidUpdate`方法才能完全正确。我们暂时忽略这一点，但会在本页的后面部分再回过头来讨论它。\n\n### 使用**`hooks`**的例子\n你可能认为我们需要单独的效果来执行清理。但是添加和删除订阅的代码是如此紧密相关，以至于`useEffect`旨在将它保持在一起。如果你的效果返回一个函数，`React`将在清理时运行它：\n```\nimport { useState, useEffect } from 'react';\n​\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n​\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n​\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // 指定如何在这种效果之后清理\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n​\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n```\n\n**为什么我们从效果中返回一个函数？** 这是效果的可选清理机制。每个效果都可能返回一个在它之后清理的函数。这使我们可以保持添加和删除彼此接近的订阅的逻辑。\n\n**React什么时候清理效果？** 当组件卸载时，React执行清理。但是，正如我们之前所了解的那样，效果会针对每个渲染运行而不仅仅是一次。这就是React在下次运行效果之前还清除前一渲染效果的原因。我们将讨论为什么这有助于避免错误以及如何在以后发生性能问题时选择退出此行为。\n> **注意:** 我们不必从效果中返回命名函数。我们在这里只是为了说明才加的命名，但你可以返回箭头函数。\n\n## 概述\n我们已经了解到useEffect让我们在组件渲染后表达不同类型的副作用。某些效果可能需要清理，因此它们返回一个函数：\n```\nuseEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n});\n```\n其他效果可能没有清理阶段，也不会返回任何内容。比如：\n```\nuseEffect(() => {\n    document.title = `You clicked ${count} times`;\n});\n```\n如果你觉得你对Effect Hook的工作方式有了很好的把握，或者你感到不知所措，那么现在就可以跳转到关于Hooks规则。\n\n---\n## 使用效果的提示\n我们将继续深入了解使用`React`用户可能会产生好奇心的`useEffect`的某些方面。\n> **提示：使用多重效果分离问题**\n\n这是一个组合了前面示例中的计数器和朋友状态指示器逻辑的组件:\n```\nclass FriendStatusWithCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0, isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n​\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n  // ...\n```\n请注意设置 `document.title` 的逻辑如何在`componentDidMount` 和`componentDidUpdate` 之间拆分。订阅逻辑也在`componentDidMount` 和 `componentWillUnmount`之间传播。`componentDidMount` 包含两个任务的代码。\n\n那么，`Hooks`如何解决这个问题呢？就像你可以多次使用状态挂钩一样，你也可以使用多种效果。这让我们将不相关的逻辑分成不同的效果：\n```\nfunction FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n​\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n​\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n  // ...\n}\n```\n**`Hooks`**允许我们根据它正在做的事情而不是生命周期方法名称来拆分代码。 React将按照指定的顺序应用组件使用的每个效果。\n\n**说明：为什么效果在每个更新上运行**\n如果你习惯了类，你可能想知道为什么每次重新渲染后效果的清理阶段都会发生，而不是在卸载过程中只发生一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建更少bug的组件。\n\n在上面介绍了一个示例FriendStatus组件，该组件显示朋友是否在线。我们的类从this.props读取friend.id，在组件挂载后订阅朋友状态，并在卸载期间取消订阅：\n```\ncomponentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n```\n**但是如果friend prop在组件出现在屏幕上时发生了变化，会发生什么？** 我们的组件将继续显示不同朋友的在线状态。这是一个错误。卸载时我们还会导致内存泄漏或崩溃，因为取消订阅会使用错误的朋友ID。\n\n在类组件中，我们需要添加componentDidUpdate来处理这种情况:\n\n```\ncomponentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentDidUpdate(prevProps) {\n    // 取消之前订阅的朋友\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    // 订阅下一个朋友\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n​\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n  \n```  \n\t\t\n忘记正确处理`componentDidUpdate`是`React`应用程序中常见的`bug`漏洞。\n现在考虑使用Hooks的这个组件的版本：\n\n\t\n\tfunction FriendStatus(props) {\n\t  // ...\n\t  useEffect(() => {\n\t\tChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n\t\treturn () => {\n\t\t  ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n\t\t};\n\t  });\n\n它不会受到这个bug的影响。 （但我们也没有对它做任何改动。）\n\n没有用于处理更新的特殊代码，因为默认情况下useEffect会处理它们。它会在应用下一个效果之前清除之前的效果。为了说明这一点，这里是一个订阅和取消订阅调用的序列，该组件可以随着时间的推移产生：\n\n\t// Mount with { friend: { id: 100 } } props\n\tChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect\n\t​\n\t// Update with { friend: { id: 200 } } props\n\tChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\n\tChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect\n\t​\n\t// Update with { friend: { id: 300 } } props\n\tChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\n\tChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect\n\t​\n\t// Unmount\n\tChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\n\t\n此行为默认确保一致性，并防止由于缺少更新逻辑而导致类组件中常见的错误。\n\n**提示：通过跳过效果优化性能**\n\n在某些情况下，在每次渲染后清理或应用效果可能会产生性能问题。在类组件中，我们可以通过在`componentDidUpdate`中编写与`prevProps`或`prevState`的额外比较来解决这个问题：\n\n\tcomponentDidUpdate(prevProps, prevState) {\n\t  if (prevState.count !== this.state.count) {\n\t\tdocument.title = `You clicked ${this.state.count} times`;\n\t  }\n\t}\n\n这个要求很常见，它被内置到`useEffect Hook` API中。如果在重新渲染之间没有更改某些值，则可以告诉`React`跳过应用效果。为此，将数组作为可选的第二个参数传递给useEffect：\n\t\n\tuseEffect(() => {\n\t  document.title = `You clicked ${count} times`;\n\t}, [count]); // 当count改变的时候回再次运行这个效果\n\t\n在上面的例子中，我们传递`[count]`作为第二个参数。这是什么意思？如果 `count` 为5，然后我们的组件重新渲染，`count`仍然等于5，则`React`将比较前一个渲染的[5]和下一个渲染的[5]。因为数组中的所有项都是相同的（`5 === 5`），所以`React`会跳过这个效果。这是我们的优化。\n\n当我们使用`count`更新为6渲染时，React会将前一渲染中[5]数组中的项目与下一渲染中[6]数组中的项目进行比较。这次，`React`将重新运行效果，因为`5！== 6`。**如果数组中有多个项目，`React`将重新运行效果，即使其中只有一个不同。**\n\n这也适用于具有清理阶段的效果：\n\n\tuseEffect(() => {\n\t  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n\t  return () => {\n\t\tChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n\t  };\n\t}, [props.friend.id]); // 只有朋友id改变重新订阅\n\n将来， 第二个参数可能会通过构建时转换自动添加。\n\n> **注意:** 如果使用此优化，请确保该数组包含外部作用域中随时间变化且效果使用的任何值，换句话说就是要在这个效果函数里有意义。 否则，代码将引用先前渲染中的旧值。我们还将讨论`Hooks API`参考中的其他优化选项。 \n\n> 如果要**运行效果并仅将其清理一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传递。** 这告诉React你的效果不依赖于来自props或 state的任何值，所以它永远不需要重新运行。这不作为特殊情况处理 - 它直接遵循输入数组的工作方式。虽然传递[]更接近熟悉的`componentDidMount`和 `componentWillUnmount`生命周期，但我们建议不要将它作为一种习惯，因为它经常会导致错误，除非你明确你自己在做什么， 如上所述。 不要忘记`React`推迟运行`useEffect`直到浏览器绘制完成后，所以做额外的工作不是问题。  \n","slug":"Effect-Hook","published":1,"updated":"2022-03-17T12:21:16.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0w0vvr6000w7cdq7bkq8f7j","content":"<h2 id=\"effect-hook\"><a href=\"#effect-hook\" class=\"headerlink\" title=\"effect-hook\"></a>effect-hook</h2><p><code>Effect Hook</code> 可以使得你在函数组件中执行一些带有副作用的方法。</p>\n <span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;useState, useEffect&#125; from &#x27;react&#x27;;</span><br><span class=\"line\">function Example ()&#123;</span><br><span class=\"line\">  const [count, setCount] = useState(0);</span><br><span class=\"line\">  useEffect(()=&gt;&#123;</span><br><span class=\"line\">    document.title = `You click $&#123;count&#125; times`</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  return(</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt; you click &#123;count&#125; times &lt;/p&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击我&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码是基于上个 <a href=\"http://www.baidu.com/\">state hook计数器的例子</a> 的例子，但是我们现在添加了新的功能，我么讲文档的标题设置为自定义消息，包含了点击次数。</p>\n<p>数据获取，设置订阅及先手动更改 <code>React</code> 组件中的 <code>DOM</code> 都是副作用的示例。无论你是否习惯与将这些操作成为“副作用”或者仅仅是“效果”，但之前你可能已经在组件中执行了这些操作。</p>\n<blockquote>\n<p> <strong>提示：</strong> 如果你熟悉<code>React</code>类组件生命周期方法，你就可以将<code>useEffect Hook</code>视为<code>componentDidMount</code>,<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的组合。</p>\n</blockquote>\n<p>React组件中有两种常见的副作用：那些需要清理的副作用和不需要清理的副作用。让我们详细的看一下两者的区别。</p>\n<hr>\n<h2 id=\"无需清理的副作用\"><a href=\"#无需清理的副作用\" class=\"headerlink\" title=\"无需清理的副作用\"></a>无需清理的副作用</h2><p>有时，我们希望在<code>React</code>更新<code>DOM</code>之后运行一些额外的代码。网络请求， 手动改变<code>DOM</code>和日志记录是不需要清理的效果（副作用，简称“效果”）的常见示例。我们这样说是因为我们可以运行他们并立即忘记他们。让我们比较一下<code>class</code>和<code>hooks</code>是如何让我们表达这样的副作用。</p>\n<h3 id=\"使用class的例子\"><a href=\"#使用class的例子\" class=\"headerlink\" title=\"使用class的例子\"></a>使用class的例子</h3><p>在<code>react</code>类组件中，<code>render</code>方法本身不应该导致副作用。这太早了，我们通常希望<code>React</code>更新<code>DOM</code>之后执行我们的效果。这就是为啥在<code>React</code>类中，我们将副作用放到<code>componentDidMount</code>和<code>componentDidUpdate</code>中。看我们的例子，这是一个<code>React</code>计数器类的组件，它在react对DOM进行更改后立即更新文档的标题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class Example extends Component &#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            count: 0</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        document.title = `You click $&#123;this.state.count&#125; times`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    componentDidUpdate() &#123;</span><br><span class=\"line\">        document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class=\"line\">              Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意<strong>我们如何在类中复制这两个生命周期方法之间的代码</strong><br>这是因为在许多的情况下，我们希望执行相同的副作用，无论组件是刚安装还是已经更新。从概念上讲，我们希望它在每次渲染之后发生，但是在React类组件中没有这样的方法（render方法应该避免更重要）。我们可以提取一个单独的方法，但是我们仍然需要在这两个地方调用它。</p>\n<p>现在让我们回头再看看我们如何使用<code>useEffect Hook</code>做同样的事情。</p>\n<p><code>useEffect</code><strong>有什么作用？</strong><br>通过使用这个Hook，你告诉React你的组件需要在渲染后执行某些操作。React将记住你传递的函数（我们将其称为“效果”），并在执行DOM更新后稍后调用它。在这个效果中，我们设置文档标题，但我们也可以执行数据提取或调用其他命令式API。</p>\n<p><strong>为什么在组件内调用<code>useEffect</code>？</strong><br>在组件中使用<code>useEffect</code>让我们可以直接从效果中访问状态变量（如count或任何道具）。我们不需要特殊的API来读取它 - 它已经在函数范围内了。Hooks拥抱<code>JavaScript</code><strong>闭包</strong>，并避免在JavaScript已经提供解决方案的情况下引入特定于React的API。</p>\n<p><strong>每次渲染后useEffect都会运行吗？</strong><br>是的。默认情况下，它在第一次渲染之后和每次更新之后运行。 （我们稍后会讨论如何自定义它。）你可能会发现更容易认为效果发生在“渲染之后”，而不是考虑“挂载”和“更新”。React保证DOM在运行‘效果’时已更新。</p>\n<h3 id=\"详细说明\"><a href=\"#详细说明\" class=\"headerlink\" title=\"详细说明\"></a>详细说明</h3><p>现在我们对这个<code>hook</code>更加的了解了，那再看看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    const[count, setCount] = useState(0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        document.title = `You clicked $&#123;count&#125; times`;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>我们声明了<code>count</code>状态变量，然后告诉<code>React</code>我们需要使用效果。我们将一个函数传递给<code>useEffect Hook</code>，这个函数式就是效果（副作用）。在我们的效果中，我们使用<code>document.title</code>浏览器<code>API</code>设置文档标题。我们可以读取效果中的最新<code>count</code>，因为它在我们的函数范围内。当<code>React</code>渲染我们的组件时，它会记住我们是用的效果，然后在更新<code>DOM</code>后运行我们的效果。每次渲染都会发生这种情况，包括第一次渲染。</p>\n<blockquote>\n<p><strong>注意：</strong> 与<code>componentDidMount</code>或<code>componentDidUpdate</code>不同，使用<code>useEffect</code>的效果不会阻止浏览器更新屏幕。这使应用感觉更具响应性。大多数效果不需要同步发生。在他们这样做的不常见情况下（例如测量布局），有一个单独的<code>useLayoutEffect Hook</code>，其<code>API</code>与<code>useEffect</code>相同。</p>\n</blockquote>\n<h2 id=\"需要清理的副作用\"><a href=\"#需要清理的副作用\" class=\"headerlink\" title=\"需要清理的副作用\"></a>需要清理的副作用</h2><p>之前，我们研究了如何表达不需要任何清理的副作用。但是，有些效果需要清理。例如，我们可能希望设置对某些外部数据源的订阅。在这种情况下，清理是非常重要的，这样我们就不会引入内存泄漏！让我们比较一下我们如何使用类和<code>Hooks</code>来实现它。</p>\n<h3 id=\"使用-class-的例子\"><a href=\"#使用-class-的例子\" class=\"headerlink\" title=\"使用 **class**的例子\"></a>使用 **<code>class</code>**的例子</h3><p>在<code>React</code>类中，通常会在<code>componentDidMount</code>中设置订阅，并在<code>componentWillUnmount</code>中清除它。例如，假设我们有一个ChatAPI`模块，可以让我们订阅朋友的在线状态。以下是我们如何使用类订阅和显示该状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FriendStatus extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; </span><br><span class=\"line\">        isOnline: null </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.handleStatusChange = this.handleStatusChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  handleStatusChange(status) &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      isOnline: status.isOnline</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    if (this.state.isOnline === null) &#123;</span><br><span class=\"line\">      return &#x27;Loading...&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.state.isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意<code>componentDidMount</code>和<code>componentWillUnmount</code>如何相互作用。生命周期方法迫使我们拆分这个逻辑，即使它们中的概念代码都与相同的效果有关。</p>\n<blockquote>\n<p><strong>注意：</strong> 眼尖的你可能会注意到这个例子还需要一个<code>componentDidUpdate</code>方法才能完全正确。我们暂时忽略这一点，但会在本页的后面部分再回过头来讨论它。</p>\n</blockquote>\n<h3 id=\"使用-hooks-的例子\"><a href=\"#使用-hooks-的例子\" class=\"headerlink\" title=\"使用**hooks**的例子\"></a>使用**<code>hooks</code>**的例子</h3><p>你可能认为我们需要单独的效果来执行清理。但是添加和删除订阅的代码是如此紧密相关，以至于<code>useEffect</code>旨在将它保持在一起。如果你的效果返回一个函数，<code>React</code>将在清理时运行它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">​</span><br><span class=\"line\">function FriendStatus(props) &#123;</span><br><span class=\"line\">  const [isOnline, setIsOnline] = useState(null);</span><br><span class=\"line\">​</span><br><span class=\"line\">  function handleStatusChange(status) &#123;</span><br><span class=\"line\">    setIsOnline(status.isOnline);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    // 指定如何在这种效果之后清理</span><br><span class=\"line\">    return function cleanup() &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">​</span><br><span class=\"line\">  if (isOnline === null) &#123;</span><br><span class=\"line\">    return &#x27;Loading...&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么我们从效果中返回一个函数？</strong> 这是效果的可选清理机制。每个效果都可能返回一个在它之后清理的函数。这使我们可以保持添加和删除彼此接近的订阅的逻辑。</p>\n<p><strong>React什么时候清理效果？</strong> 当组件卸载时，React执行清理。但是，正如我们之前所了解的那样，效果会针对每个渲染运行而不仅仅是一次。这就是React在下次运行效果之前还清除前一渲染效果的原因。我们将讨论为什么这有助于避免错误以及如何在以后发生性能问题时选择退出此行为。</p>\n<blockquote>\n<p><strong>注意:</strong> 我们不必从效果中返回命名函数。我们在这里只是为了说明才加的命名，但你可以返回箭头函数。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>我们已经了解到useEffect让我们在组件渲染后表达不同类型的副作用。某些效果可能需要清理，因此它们返回一个函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>其他效果可能没有清理阶段，也不会返回任何内容。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你觉得你对Effect Hook的工作方式有了很好的把握，或者你感到不知所措，那么现在就可以跳转到关于Hooks规则。</p>\n<hr>\n<h2 id=\"使用效果的提示\"><a href=\"#使用效果的提示\" class=\"headerlink\" title=\"使用效果的提示\"></a>使用效果的提示</h2><p>我们将继续深入了解使用<code>React</code>用户可能会产生好奇心的<code>useEffect</code>的某些方面。</p>\n<blockquote>\n<p><strong>提示：使用多重效果分离问题</strong></p>\n</blockquote>\n<p>这是一个组合了前面示例中的计数器和朋友状态指示器逻辑的组件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FriendStatusWithCounter extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; count: 0, isOnline: null &#125;;</span><br><span class=\"line\">    this.handleStatusChange = this.handleStatusChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentDidUpdate() &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  handleStatusChange(status) &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      isOnline: status.isOnline</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // ...</span><br></pre></td></tr></table></figure>\n<p>请注意设置 <code>document.title</code> 的逻辑如何在<code>componentDidMount</code> 和<code>componentDidUpdate</code> 之间拆分。订阅逻辑也在<code>componentDidMount</code> 和 <code>componentWillUnmount</code>之间传播。<code>componentDidMount</code> 包含两个任务的代码。</p>\n<p>那么，<code>Hooks</code>如何解决这个问题呢？就像你可以多次使用状态挂钩一样，你也可以使用多种效果。这让我们将不相关的逻辑分成不同的效果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function FriendStatusWithCounter(props) &#123;</span><br><span class=\"line\">  const [count, setCount] = useState(0);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">​</span><br><span class=\"line\">  const [isOnline, setIsOnline] = useState(null);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">​</span><br><span class=\"line\">  function handleStatusChange(status) &#123;</span><br><span class=\"line\">    setIsOnline(status.isOnline);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>**<code>Hooks</code>**允许我们根据它正在做的事情而不是生命周期方法名称来拆分代码。 React将按照指定的顺序应用组件使用的每个效果。</p>\n<p><strong>说明：为什么效果在每个更新上运行</strong><br>如果你习惯了类，你可能想知道为什么每次重新渲染后效果的清理阶段都会发生，而不是在卸载过程中只发生一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建更少bug的组件。</p>\n<p>在上面介绍了一个示例FriendStatus组件，该组件显示朋友是否在线。我们的类从this.props读取friend.id，在组件挂载后订阅朋友状态，并在卸载期间取消订阅：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>但是如果friend prop在组件出现在屏幕上时发生了变化，会发生什么？</strong> 我们的组件将继续显示不同朋友的在线状态。这是一个错误。卸载时我们还会导致内存泄漏或崩溃，因为取消订阅会使用错误的朋友ID。</p>\n<p>在类组件中，我们需要添加componentDidUpdate来处理这种情况:</p>\n<pre><code>componentDidMount() &#123;\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  &#125;\n​\n  componentDidUpdate(prevProps) &#123;\n    // 取消之前订阅的朋友\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    // 订阅下一个朋友\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  &#125;\n​\n  componentWillUnmount() &#123;\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  &#125;\n  \n</code></pre>\n<p>忘记正确处理<code>componentDidUpdate</code>是<code>React</code>应用程序中常见的<code>bug</code>漏洞。<br>现在考虑使用Hooks的这个组件的版本：</p>\n<pre><code>function FriendStatus(props) &#123;\n  // ...\n  useEffect(() =&gt; &#123;\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () =&gt; &#123;\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    &#125;;\n  &#125;);\n</code></pre>\n<p>它不会受到这个bug的影响。 （但我们也没有对它做任何改动。）</p>\n<p>没有用于处理更新的特殊代码，因为默认情况下useEffect会处理它们。它会在应用下一个效果之前清除之前的效果。为了说明这一点，这里是一个订阅和取消订阅调用的序列，该组件可以随着时间的推移产生：</p>\n<pre><code>// Mount with &#123; friend: &#123; id: 100 &#125; &#125; props\nChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect\n​\n// Update with &#123; friend: &#123; id: 200 &#125; &#125; props\nChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect\n​\n// Update with &#123; friend: &#123; id: 300 &#125; &#125; props\nChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect\n​\n// Unmount\nChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\n</code></pre>\n<p>此行为默认确保一致性，并防止由于缺少更新逻辑而导致类组件中常见的错误。</p>\n<p><strong>提示：通过跳过效果优化性能</strong></p>\n<p>在某些情况下，在每次渲染后清理或应用效果可能会产生性能问题。在类组件中，我们可以通过在<code>componentDidUpdate</code>中编写与<code>prevProps</code>或<code>prevState</code>的额外比较来解决这个问题：</p>\n<pre><code>componentDidUpdate(prevProps, prevState) &#123;\n  if (prevState.count !== this.state.count) &#123;\n    document.title = `You clicked $&#123;this.state.count&#125; times`;\n  &#125;\n&#125;\n</code></pre>\n<p>这个要求很常见，它被内置到<code>useEffect Hook</code> API中。如果在重新渲染之间没有更改某些值，则可以告诉<code>React</code>跳过应用效果。为此，将数组作为可选的第二个参数传递给useEffect：</p>\n<pre><code>useEffect(() =&gt; &#123;\n  document.title = `You clicked $&#123;count&#125; times`;\n&#125;, [count]); // 当count改变的时候回再次运行这个效果\n</code></pre>\n<p>在上面的例子中，我们传递<code>[count]</code>作为第二个参数。这是什么意思？如果 <code>count</code> 为5，然后我们的组件重新渲染，<code>count</code>仍然等于5，则<code>React</code>将比较前一个渲染的[5]和下一个渲染的[5]。因为数组中的所有项都是相同的（<code>5 === 5</code>），所以<code>React</code>会跳过这个效果。这是我们的优化。</p>\n<p>当我们使用<code>count</code>更新为6渲染时，React会将前一渲染中[5]数组中的项目与下一渲染中[6]数组中的项目进行比较。这次，<code>React</code>将重新运行效果，因为<code>5！== 6</code>。<strong>如果数组中有多个项目，<code>React</code>将重新运行效果，即使其中只有一个不同。</strong></p>\n<p>这也适用于具有清理阶段的效果：</p>\n<pre><code>useEffect(() =&gt; &#123;\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () =&gt; &#123;\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  &#125;;\n&#125;, [props.friend.id]); // 只有朋友id改变重新订阅\n</code></pre>\n<p>将来， 第二个参数可能会通过构建时转换自动添加。</p>\n<blockquote>\n<p><strong>注意:</strong> 如果使用此优化，请确保该数组包含外部作用域中随时间变化且效果使用的任何值，换句话说就是要在这个效果函数里有意义。 否则，代码将引用先前渲染中的旧值。我们还将讨论<code>Hooks API</code>参考中的其他优化选项。 </p>\n</blockquote>\n<blockquote>\n<p>如果要<strong>运行效果并仅将其清理一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传递。</strong> 这告诉React你的效果不依赖于来自props或 state的任何值，所以它永远不需要重新运行。这不作为特殊情况处理 - 它直接遵循输入数组的工作方式。虽然传递[]更接近熟悉的<code>componentDidMount</code>和 <code>componentWillUnmount</code>生命周期，但我们建议不要将它作为一种习惯，因为它经常会导致错误，除非你明确你自己在做什么， 如上所述。 不要忘记<code>React</code>推迟运行<code>useEffect</code>直到浏览器绘制完成后，所以做额外的工作不是问题。  </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"effect-hook\"><a href=\"#effect-hook\" class=\"headerlink\" title=\"effect-hook\"></a>effect-hook</h2><p><code>Effect Hook</code> 可以使得你在函数组件中执行一些带有副作用的方法。</p>","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;useState, useEffect&#125; from &#x27;react&#x27;;</span><br><span class=\"line\">function Example ()&#123;</span><br><span class=\"line\">  const [count, setCount] = useState(0);</span><br><span class=\"line\">  useEffect(()=&gt;&#123;</span><br><span class=\"line\">    document.title = `You click $&#123;count&#125; times`</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  return(</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt; you click &#123;count&#125; times &lt;/p&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;点击我&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码是基于上个 <a href=\"http://www.baidu.com/\">state hook计数器的例子</a> 的例子，但是我们现在添加了新的功能，我么讲文档的标题设置为自定义消息，包含了点击次数。</p>\n<p>数据获取，设置订阅及先手动更改 <code>React</code> 组件中的 <code>DOM</code> 都是副作用的示例。无论你是否习惯与将这些操作成为“副作用”或者仅仅是“效果”，但之前你可能已经在组件中执行了这些操作。</p>\n<blockquote>\n<p> <strong>提示：</strong> 如果你熟悉<code>React</code>类组件生命周期方法，你就可以将<code>useEffect Hook</code>视为<code>componentDidMount</code>,<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的组合。</p>\n</blockquote>\n<p>React组件中有两种常见的副作用：那些需要清理的副作用和不需要清理的副作用。让我们详细的看一下两者的区别。</p>\n<hr>\n<h2 id=\"无需清理的副作用\"><a href=\"#无需清理的副作用\" class=\"headerlink\" title=\"无需清理的副作用\"></a>无需清理的副作用</h2><p>有时，我们希望在<code>React</code>更新<code>DOM</code>之后运行一些额外的代码。网络请求， 手动改变<code>DOM</code>和日志记录是不需要清理的效果（副作用，简称“效果”）的常见示例。我们这样说是因为我们可以运行他们并立即忘记他们。让我们比较一下<code>class</code>和<code>hooks</code>是如何让我们表达这样的副作用。</p>\n<h3 id=\"使用class的例子\"><a href=\"#使用class的例子\" class=\"headerlink\" title=\"使用class的例子\"></a>使用class的例子</h3><p>在<code>react</code>类组件中，<code>render</code>方法本身不应该导致副作用。这太早了，我们通常希望<code>React</code>更新<code>DOM</code>之后执行我们的效果。这就是为啥在<code>React</code>类中，我们将副作用放到<code>componentDidMount</code>和<code>componentDidUpdate</code>中。看我们的例子，这是一个<code>React</code>计数器类的组件，它在react对DOM进行更改后立即更新文档的标题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#x27;react&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class Example extends Component &#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props);</span><br><span class=\"line\">        this.state = &#123;</span><br><span class=\"line\">            count: 0</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        document.title = `You click $&#123;this.state.count&#125; times`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    componentDidUpdate() &#123;</span><br><span class=\"line\">        document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class=\"line\">              Click me</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意<strong>我们如何在类中复制这两个生命周期方法之间的代码</strong><br>这是因为在许多的情况下，我们希望执行相同的副作用，无论组件是刚安装还是已经更新。从概念上讲，我们希望它在每次渲染之后发生，但是在React类组件中没有这样的方法（render方法应该避免更重要）。我们可以提取一个单独的方法，但是我们仍然需要在这两个地方调用它。</p>\n<p>现在让我们回头再看看我们如何使用<code>useEffect Hook</code>做同样的事情。</p>\n<p><code>useEffect</code><strong>有什么作用？</strong><br>通过使用这个Hook，你告诉React你的组件需要在渲染后执行某些操作。React将记住你传递的函数（我们将其称为“效果”），并在执行DOM更新后稍后调用它。在这个效果中，我们设置文档标题，但我们也可以执行数据提取或调用其他命令式API。</p>\n<p><strong>为什么在组件内调用<code>useEffect</code>？</strong><br>在组件中使用<code>useEffect</code>让我们可以直接从效果中访问状态变量（如count或任何道具）。我们不需要特殊的API来读取它 - 它已经在函数范围内了。Hooks拥抱<code>JavaScript</code><strong>闭包</strong>，并避免在JavaScript已经提供解决方案的情况下引入特定于React的API。</p>\n<p><strong>每次渲染后useEffect都会运行吗？</strong><br>是的。默认情况下，它在第一次渲染之后和每次更新之后运行。 （我们稍后会讨论如何自定义它。）你可能会发现更容易认为效果发生在“渲染之后”，而不是考虑“挂载”和“更新”。React保证DOM在运行‘效果’时已更新。</p>\n<h3 id=\"详细说明\"><a href=\"#详细说明\" class=\"headerlink\" title=\"详细说明\"></a>详细说明</h3><p>现在我们对这个<code>hook</code>更加的了解了，那再看看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Example() &#123;</span><br><span class=\"line\">    const[count, setCount] = useState(0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        document.title = `You clicked $&#123;count&#125; times`;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>我们声明了<code>count</code>状态变量，然后告诉<code>React</code>我们需要使用效果。我们将一个函数传递给<code>useEffect Hook</code>，这个函数式就是效果（副作用）。在我们的效果中，我们使用<code>document.title</code>浏览器<code>API</code>设置文档标题。我们可以读取效果中的最新<code>count</code>，因为它在我们的函数范围内。当<code>React</code>渲染我们的组件时，它会记住我们是用的效果，然后在更新<code>DOM</code>后运行我们的效果。每次渲染都会发生这种情况，包括第一次渲染。</p>\n<blockquote>\n<p><strong>注意：</strong> 与<code>componentDidMount</code>或<code>componentDidUpdate</code>不同，使用<code>useEffect</code>的效果不会阻止浏览器更新屏幕。这使应用感觉更具响应性。大多数效果不需要同步发生。在他们这样做的不常见情况下（例如测量布局），有一个单独的<code>useLayoutEffect Hook</code>，其<code>API</code>与<code>useEffect</code>相同。</p>\n</blockquote>\n<h2 id=\"需要清理的副作用\"><a href=\"#需要清理的副作用\" class=\"headerlink\" title=\"需要清理的副作用\"></a>需要清理的副作用</h2><p>之前，我们研究了如何表达不需要任何清理的副作用。但是，有些效果需要清理。例如，我们可能希望设置对某些外部数据源的订阅。在这种情况下，清理是非常重要的，这样我们就不会引入内存泄漏！让我们比较一下我们如何使用类和<code>Hooks</code>来实现它。</p>\n<h3 id=\"使用-class-的例子\"><a href=\"#使用-class-的例子\" class=\"headerlink\" title=\"使用 **class**的例子\"></a>使用 **<code>class</code>**的例子</h3><p>在<code>React</code>类中，通常会在<code>componentDidMount</code>中设置订阅，并在<code>componentWillUnmount</code>中清除它。例如，假设我们有一个ChatAPI`模块，可以让我们订阅朋友的在线状态。以下是我们如何使用类订阅和显示该状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FriendStatus extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; </span><br><span class=\"line\">        isOnline: null </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.handleStatusChange = this.handleStatusChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  handleStatusChange(status) &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      isOnline: status.isOnline</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    if (this.state.isOnline === null) &#123;</span><br><span class=\"line\">      return &#x27;Loading...&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.state.isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意<code>componentDidMount</code>和<code>componentWillUnmount</code>如何相互作用。生命周期方法迫使我们拆分这个逻辑，即使它们中的概念代码都与相同的效果有关。</p>\n<blockquote>\n<p><strong>注意：</strong> 眼尖的你可能会注意到这个例子还需要一个<code>componentDidUpdate</code>方法才能完全正确。我们暂时忽略这一点，但会在本页的后面部分再回过头来讨论它。</p>\n</blockquote>\n<h3 id=\"使用-hooks-的例子\"><a href=\"#使用-hooks-的例子\" class=\"headerlink\" title=\"使用**hooks**的例子\"></a>使用**<code>hooks</code>**的例子</h3><p>你可能认为我们需要单独的效果来执行清理。但是添加和删除订阅的代码是如此紧密相关，以至于<code>useEffect</code>旨在将它保持在一起。如果你的效果返回一个函数，<code>React</code>将在清理时运行它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class=\"line\">​</span><br><span class=\"line\">function FriendStatus(props) &#123;</span><br><span class=\"line\">  const [isOnline, setIsOnline] = useState(null);</span><br><span class=\"line\">​</span><br><span class=\"line\">  function handleStatusChange(status) &#123;</span><br><span class=\"line\">    setIsOnline(status.isOnline);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    // 指定如何在这种效果之后清理</span><br><span class=\"line\">    return function cleanup() &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">​</span><br><span class=\"line\">  if (isOnline === null) &#123;</span><br><span class=\"line\">    return &#x27;Loading...&#x27;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么我们从效果中返回一个函数？</strong> 这是效果的可选清理机制。每个效果都可能返回一个在它之后清理的函数。这使我们可以保持添加和删除彼此接近的订阅的逻辑。</p>\n<p><strong>React什么时候清理效果？</strong> 当组件卸载时，React执行清理。但是，正如我们之前所了解的那样，效果会针对每个渲染运行而不仅仅是一次。这就是React在下次运行效果之前还清除前一渲染效果的原因。我们将讨论为什么这有助于避免错误以及如何在以后发生性能问题时选择退出此行为。</p>\n<blockquote>\n<p><strong>注意:</strong> 我们不必从效果中返回命名函数。我们在这里只是为了说明才加的命名，但你可以返回箭头函数。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>我们已经了解到useEffect让我们在组件渲染后表达不同类型的副作用。某些效果可能需要清理，因此它们返回一个函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>其他效果可能没有清理阶段，也不会返回任何内容。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你觉得你对Effect Hook的工作方式有了很好的把握，或者你感到不知所措，那么现在就可以跳转到关于Hooks规则。</p>\n<hr>\n<h2 id=\"使用效果的提示\"><a href=\"#使用效果的提示\" class=\"headerlink\" title=\"使用效果的提示\"></a>使用效果的提示</h2><p>我们将继续深入了解使用<code>React</code>用户可能会产生好奇心的<code>useEffect</code>的某些方面。</p>\n<blockquote>\n<p><strong>提示：使用多重效果分离问题</strong></p>\n</blockquote>\n<p>这是一个组合了前面示例中的计数器和朋友状态指示器逻辑的组件:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FriendStatusWithCounter extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; count: 0, isOnline: null &#125;;</span><br><span class=\"line\">    this.handleStatusChange = this.handleStatusChange.bind(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentDidUpdate() &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  handleStatusChange(status) &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      isOnline: status.isOnline</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // ...</span><br></pre></td></tr></table></figure>\n<p>请注意设置 <code>document.title</code> 的逻辑如何在<code>componentDidMount</code> 和<code>componentDidUpdate</code> 之间拆分。订阅逻辑也在<code>componentDidMount</code> 和 <code>componentWillUnmount</code>之间传播。<code>componentDidMount</code> 包含两个任务的代码。</p>\n<p>那么，<code>Hooks</code>如何解决这个问题呢？就像你可以多次使用状态挂钩一样，你也可以使用多种效果。这让我们将不相关的逻辑分成不同的效果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function FriendStatusWithCounter(props) &#123;</span><br><span class=\"line\">  const [count, setCount] = useState(0);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">​</span><br><span class=\"line\">  const [isOnline, setIsOnline] = useState(null);</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">​</span><br><span class=\"line\">  function handleStatusChange(status) &#123;</span><br><span class=\"line\">    setIsOnline(status.isOnline);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>**<code>Hooks</code>**允许我们根据它正在做的事情而不是生命周期方法名称来拆分代码。 React将按照指定的顺序应用组件使用的每个效果。</p>\n<p><strong>说明：为什么效果在每个更新上运行</strong><br>如果你习惯了类，你可能想知道为什么每次重新渲染后效果的清理阶段都会发生，而不是在卸载过程中只发生一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建更少bug的组件。</p>\n<p>在上面介绍了一个示例FriendStatus组件，该组件显示朋友是否在线。我们的类从this.props读取friend.id，在组件挂载后订阅朋友状态，并在卸载期间取消订阅：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">​</span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class=\"line\">      this.props.friend.id,</span><br><span class=\"line\">      this.handleStatusChange</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>但是如果friend prop在组件出现在屏幕上时发生了变化，会发生什么？</strong> 我们的组件将继续显示不同朋友的在线状态。这是一个错误。卸载时我们还会导致内存泄漏或崩溃，因为取消订阅会使用错误的朋友ID。</p>\n<p>在类组件中，我们需要添加componentDidUpdate来处理这种情况:</p>\n<pre><code>componentDidMount() &#123;\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  &#125;\n​\n  componentDidUpdate(prevProps) &#123;\n    // 取消之前订阅的朋友\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    // 订阅下一个朋友\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  &#125;\n​\n  componentWillUnmount() &#123;\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  &#125;\n  \n</code></pre>\n<p>忘记正确处理<code>componentDidUpdate</code>是<code>React</code>应用程序中常见的<code>bug</code>漏洞。<br>现在考虑使用Hooks的这个组件的版本：</p>\n<pre><code>function FriendStatus(props) &#123;\n  // ...\n  useEffect(() =&gt; &#123;\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () =&gt; &#123;\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    &#125;;\n  &#125;);\n</code></pre>\n<p>它不会受到这个bug的影响。 （但我们也没有对它做任何改动。）</p>\n<p>没有用于处理更新的特殊代码，因为默认情况下useEffect会处理它们。它会在应用下一个效果之前清除之前的效果。为了说明这一点，这里是一个订阅和取消订阅调用的序列，该组件可以随着时间的推移产生：</p>\n<pre><code>// Mount with &#123; friend: &#123; id: 100 &#125; &#125; props\nChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect\n​\n// Update with &#123; friend: &#123; id: 200 &#125; &#125; props\nChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect\n​\n// Update with &#123; friend: &#123; id: 300 &#125; &#125; props\nChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect\nChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect\n​\n// Unmount\nChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect\n</code></pre>\n<p>此行为默认确保一致性，并防止由于缺少更新逻辑而导致类组件中常见的错误。</p>\n<p><strong>提示：通过跳过效果优化性能</strong></p>\n<p>在某些情况下，在每次渲染后清理或应用效果可能会产生性能问题。在类组件中，我们可以通过在<code>componentDidUpdate</code>中编写与<code>prevProps</code>或<code>prevState</code>的额外比较来解决这个问题：</p>\n<pre><code>componentDidUpdate(prevProps, prevState) &#123;\n  if (prevState.count !== this.state.count) &#123;\n    document.title = `You clicked $&#123;this.state.count&#125; times`;\n  &#125;\n&#125;\n</code></pre>\n<p>这个要求很常见，它被内置到<code>useEffect Hook</code> API中。如果在重新渲染之间没有更改某些值，则可以告诉<code>React</code>跳过应用效果。为此，将数组作为可选的第二个参数传递给useEffect：</p>\n<pre><code>useEffect(() =&gt; &#123;\n  document.title = `You clicked $&#123;count&#125; times`;\n&#125;, [count]); // 当count改变的时候回再次运行这个效果\n</code></pre>\n<p>在上面的例子中，我们传递<code>[count]</code>作为第二个参数。这是什么意思？如果 <code>count</code> 为5，然后我们的组件重新渲染，<code>count</code>仍然等于5，则<code>React</code>将比较前一个渲染的[5]和下一个渲染的[5]。因为数组中的所有项都是相同的（<code>5 === 5</code>），所以<code>React</code>会跳过这个效果。这是我们的优化。</p>\n<p>当我们使用<code>count</code>更新为6渲染时，React会将前一渲染中[5]数组中的项目与下一渲染中[6]数组中的项目进行比较。这次，<code>React</code>将重新运行效果，因为<code>5！== 6</code>。<strong>如果数组中有多个项目，<code>React</code>将重新运行效果，即使其中只有一个不同。</strong></p>\n<p>这也适用于具有清理阶段的效果：</p>\n<pre><code>useEffect(() =&gt; &#123;\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () =&gt; &#123;\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  &#125;;\n&#125;, [props.friend.id]); // 只有朋友id改变重新订阅\n</code></pre>\n<p>将来， 第二个参数可能会通过构建时转换自动添加。</p>\n<blockquote>\n<p><strong>注意:</strong> 如果使用此优化，请确保该数组包含外部作用域中随时间变化且效果使用的任何值，换句话说就是要在这个效果函数里有意义。 否则，代码将引用先前渲染中的旧值。我们还将讨论<code>Hooks API</code>参考中的其他优化选项。 </p>\n</blockquote>\n<blockquote>\n<p>如果要<strong>运行效果并仅将其清理一次（在装载和卸载时），则可以将空数组（[]）作为第二个参数传递。</strong> 这告诉React你的效果不依赖于来自props或 state的任何值，所以它永远不需要重新运行。这不作为特殊情况处理 - 它直接遵循输入数组的工作方式。虽然传递[]更接近熟悉的<code>componentDidMount</code>和 <code>componentWillUnmount</code>生命周期，但我们建议不要将它作为一种习惯，因为它经常会导致错误，除非你明确你自己在做什么， 如上所述。 不要忘记<code>React</code>推迟运行<code>useEffect</code>直到浏览器绘制完成后，所以做额外的工作不是问题。  </p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0w0vvqm00087cdq62ps49zo","category_id":"cl0w0vvqc00047cdqhrcab467","_id":"cl0w0vvqr000e7cdqcutf2cdz"},{"post_id":"cl0w0vvq700017cdqc43lc228","category_id":"cl0w0vvqc00047cdqhrcab467","_id":"cl0w0vvqs000h7cdqfuay0kn9"},{"post_id":"cl0w0vvqa00037cdqeg4fhn3r","category_id":"cl0w0vvqc00047cdqhrcab467","_id":"cl0w0vvqs000i7cdq265q60ey"},{"post_id":"cl0w0vvqh00077cdqhfwtebpp","category_id":"cl0w0vvqr000f7cdq68xtciz7","_id":"cl0w0vvqu000n7cdqfcxq3v5g"},{"post_id":"cl0w0vvqo00097cdq2w1l06yj","category_id":"cl0w0vvqr000f7cdq68xtciz7","_id":"cl0w0vvqw000t7cdq32uwbzox"},{"post_id":"cl0w0vvqo00097cdq2w1l06yj","category_id":"cl0w0vvqu000q7cdq3szlbt30","_id":"cl0w0vvqw000v7cdq1zsw61i7"},{"post_id":"cl0w0vvr6000w7cdq7bkq8f7j","category_id":"cl0w0vvqr000f7cdq68xtciz7","_id":"cl0w0vvr7000z7cdq403eh6ta"},{"post_id":"cl0w0vvr6000w7cdq7bkq8f7j","category_id":"cl0w0vvqu000q7cdq3szlbt30","_id":"cl0w0vvr700107cdqacqb7dvy"}],"PostTag":[{"post_id":"cl0w0vvqm00087cdq62ps49zo","tag_id":"cl0w0vvqd00057cdq8cuo14ln","_id":"cl0w0vvqq000c7cdqgzws66b5"},{"post_id":"cl0w0vvq700017cdqc43lc228","tag_id":"cl0w0vvqd00057cdq8cuo14ln","_id":"cl0w0vvqr000d7cdqbw10gh6g"},{"post_id":"cl0w0vvqa00037cdqeg4fhn3r","tag_id":"cl0w0vvqd00057cdq8cuo14ln","_id":"cl0w0vvqt000l7cdq9emday89"},{"post_id":"cl0w0vvqa00037cdqeg4fhn3r","tag_id":"cl0w0vvqr000g7cdq2n2ph4q2","_id":"cl0w0vvqt000m7cdq4rz105lq"},{"post_id":"cl0w0vvqh00077cdqhfwtebpp","tag_id":"cl0w0vvqr000g7cdq2n2ph4q2","_id":"cl0w0vvqu000p7cdqhh4xh9p0"},{"post_id":"cl0w0vvqo00097cdq2w1l06yj","tag_id":"cl0w0vvqr000g7cdq2n2ph4q2","_id":"cl0w0vvqv000s7cdq62po3cnm"},{"post_id":"cl0w0vvqo00097cdq2w1l06yj","tag_id":"cl0w0vvqv000r7cdq5yd653cl","_id":"cl0w0vvqw000u7cdqaqbw3qhy"},{"post_id":"cl0w0vvr6000w7cdq7bkq8f7j","tag_id":"cl0w0vvqr000g7cdq2n2ph4q2","_id":"cl0w0vvr7000x7cdqgqfbc0ph"},{"post_id":"cl0w0vvr6000w7cdq7bkq8f7j","tag_id":"cl0w0vvqv000r7cdq5yd653cl","_id":"cl0w0vvr7000y7cdqf8uh1ie2"}],"Tag":[{"name":"react-native","_id":"cl0w0vvqd00057cdq8cuo14ln"},{"name":"react","_id":"cl0w0vvqr000g7cdq2n2ph4q2"},{"name":"react-hooks","_id":"cl0w0vvqv000r7cdq5yd653cl"}]}}